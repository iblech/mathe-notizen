=== Obere Schranken für Gegenbeispiele und Beweise

Gustavo Lacerda.
Upper-Bounding Proof Length with the Busy Beaver.
http://arxiv.org/abs/1406.1808

Sehr einfach zu verstehen!


=== Notions of computability at higher types

http://cstheory.stackexchange.com/questions/1117/realizability-theory-difference-in-power-between-lambda-calculus-and-turing-mac
http://homepages.inf.ed.ac.uk/jrl/Research/notions1.pdf


=== Der Kleene-Baum

* Es gibt eine berechenbare partielle Funktion d : N --` {0,1} sodass für
  jede berechenbare totale Funktion f : N --> N eine natürliche Zahl n
  existiert, sodass d(n) definiert ist und ungleich f(n) ist.

  Dazu definiere d(n) so: Simuliere die n-te Turingmaschine mit Eingabe n.
  Falls das nicht terminiert, ist der Wert von d(n) undefiniert. Ansonsten ist
  er 0, falls das Ergebnis nicht 0 war, und 1 sonst.

  Ist nun eine berechenbare totale Funktion f gegeben, so gibt es ein n,
  sodass f durch die n-te Turingmaschine realisiert wird. Folglich ist d(n)
  definiert und gleich f(n).

* Ein Wort a in 2^* liegt genau dann im Kleene-Baum, wenn a "die Folge d
  sein könnte". Damit ist folgendes gemeint.

  Fixiere eine Maschine D, die d berechnet, etwa die oben skizzierte.
  Ein Wort a der Länge l liegt genau dann im Kleene-Baum, wenn für
  alle 1 <= i <= l, für die D(i) nach höchstens l Schritten terminiert hat,
  gilt, dass der i-te Buchstabe von a gleich d(i) ist.

* Der Kleene-Baum enthält (berechenbar) unendlich viele Elemente.

  Denn sei n eine beliebige Zahl. Dann definieren wir die Buchstabenfolge
  a_1...a_n durch

      a_k := d(k), falls D(k) nach <= n Schritten gehalten hat;
             0,    sonst.

* Nach Königs Lemma enthält der Kleene-Baum daher einen unendlichen Pfad.
  Aber er enthält keinen berechenbaren unendlichen Pfad.
  
  Denn sei ein beliebiger berechenbarer Pfad in 2^* gegeben. Dann können wir
  eine totale berechenbare Funktion f : N --> {0,1} durch f(n) := der n-te
  Buchstabe des n-ten Worts auf dem Pfad definieren. Dank der Magie von d
  gibt es eine natürliche Zahl n für die d(n) definiert und ungleich f(n) ist.
  Sei m die Anzahl Schritte, die D(n) bis zur Terminierung benötigt. Ohne
  Einschränkung m >= n. Dann liegt das m-te Wort des Pfads nicht im Kleene-Baum.

* Andrej erklärt das in Realizability for the Physical World so: "To understand how
  strange such a tree is, contemplate the following situation. A master machine
  has built a system of underground tunnels, beginning with a hole at the
  surface. The tunnels always go down, they may split into two, or lead to dead
  ends. We are told that there is no limit to the depth of the tunnels. Yet,
  even if the master machine is known to us we cannot build a machine that
  would enter the hole and always go down without ever hitting a dead end."

* Der Kleene-Baum liefert eine Funktion psi : 2^N --> N (das Exponential soll nur
  die berechenbaren Funktionen enthalten), die nicht gleichmäßig stetig ist:
  Bilde f ab auf die kleinste natürliche Zahl n, sodass das Wort
  [f(0),...,f(n-1)] nicht im Kleene-Baum liegt.

  Stetig ist diese Funktion aber schon: Sei eine Funktion f mit psi(f) = n
  gegeben. Dann gilt psi(f) = psi(g) für alle berechenbaren Funktionen g
  mit f = g auf { 0, ..., n - 1 }.

  Zudem ist diese Funktion nicht beschränkt.

  https://books.google.de/books?id=j6f9CAAAQBAJ&pg=PA70&lpg=PA70
  (Beeson, Foundations of Constructive Mathematics: Metamathematical Studies)

* In PCF ist eine Funktion

      max :: (2^N --> N) --> N

  definierbar. Aber im Modell mit Turingmaschinen (welche im Falle von
  Funktionen höherer Ordnungen passende Kodierungen von sie berechnenden
  Turingmaschinen als Argumente nehmen) funktioniert die Funktion nicht:
  Wegen der nicht beschränkten Funktion aus dem Kleene-Baum.

  Wenn man das Modell so ändert, dass Funktionen durch ihren Graph übergeben
  werden, funktioniert sie wieder. Angeblich, ist mir noch nicht ganz klar.
  Zumindest nicht im Realisierbarkeitsmodell. Hm.

* Sei s : X --> Y eine Surjektion. Existiere eine Funktion

      all : 2^X --> 2

  mit all(p) genau dann, wenn p(x) für alle x in X. Dann gibt es auch die
  analoge Funktion für Y.

* Existiere der Kleene-Baum T. Dann gibt es eine Surjektion 2^N --> N,
  nämlich diejenige Abbildung, die einem unendlichen Pfad die Blattnummer des
  letzten in T befindlichen Knotens des Pfads zuordnet.

  Es gibt auch eine passende rechtsinverse Injektion: Die ordnet einer Zahl n
  einen Pfad zu, der zum n-ten Blatt läuft (und dann immer links abbiegt).

  Ferner ist 2^N isomorph (als metrische Räume, vermöge einer stetigen
  Bijektion mit stetiger Inversem) zu N^N.

* Angenommen, es gibt "all" für X = 2^N. Existiere weiterhin der Kleene-Baum.
  Dann gibt es "all" auch für Y = N. Das ist aber falsch, weil damit das
  Halteproblem lösbar ist.


=== Noethers Theorem aus "Theorems for free"

http://lambda-the-ultimate.org/node/5078

Robert Atkey
Conservation laws for free!

Invariance is of paramount importance in programming languages and in
physics. In programming languages, John Reynolds’ theory of relational
parametricity demonstrates that parametric polymorphic programs are
invariant under change of data representation, a property that yields
“free” theorems about programs just from their types. In physics, Emmy
Noether showed that if the action of a physical system is invariant
under change of coordinates, then the physical system has a conserved
quantity: a quantity that remains constant for all time. Knowledge of
conserved quantities can reveal deep properties of physical systems. For
example, the conservation of energy, which by Noether’s theorem is a
consequence of a system’s invariance under time-shifting.

In this paper, we link Reynolds’ relational parametricity with Noether’s
theorem for deriving conserved quantities. We propose an extension of
System Fω with new kinds, types and term constants for writing programs
that describe classical mechanical systems in terms of their
Lagrangians. We show, by constructing a relationally parametric model of
our extension of Fω, that relational parametricity is enough to satisfy
the hypotheses of Noether’s theorem, and so to derive conserved
quantities for free, directly from the polymorphic types of Lagrangians
expressed in our system.


=== Fixpunktsatz von Knaster--Tarski

* Sei X ein vollständiger Verband. Sei f : X --> X ein monotoner Operator.
  Dann besitzt f einen größten Fixpunkt, und diesen kann man konstruieren als

      u := sup M  mit  M := { v | v <= f(v) }.

  Zunächst ist klar, dass u existiert.
  Ferner M <= f(u), denn für v in M (also v <= u) gilt v <= f(v) <= f(u).
  Also auch u <= f(u). Somit u in M.
  Dann auch f(u) in M. Also f(u) <= u.
  Also ist u ein Fixpunkt.

  Ferner ist u der größte Fixpunkt. Sei v irgendein Fixpunkt von f.
  Dann v in M. Also v <= u.

* Den kleinsten Fixpunkt bekommt man so:

      u := inf M  mit  M := { v | f(v) <= v }.

  Zunächst ist klar, dass u existiert.
  Ferner f(u) <= M, denn für v in M (also v >= u) gilt f(u) <= f(v) <= v.
  Also auch f(u) <= u. Somit u in M.
  Dann auch f(u) in M. Also f(u) >= u.
  Also ist u ein Fixpunkt.

  Ferner ist u der kleinste Fixpunkt. Sei v irgendein Fixpunkt von f.
  Dann v in M. Also u <= v.

* Und hier noch eine Konstruktionsmöglichkeit für den kleinsten Fixpunkt,
  wenn f Suprema von aufsteigenden Folgen bewahrt:

      u := sup M  mit  M := { bot, f(bot), f^2(bot), ... }.

  Dann f(u) =Vor= sup { f(bot), f^2(bot), ... } = sup M = u.

  Ferner ist u kleinster Fixpunkt, denn ist v irgendein Fixpunkt, so zeigt man
  durch Induktion, dass M <= v. Also auch u <= v.

* Sei X ein vollständiger Verband. Sei f : X --> X ein monotoner Operator.
  Dann gilt für alle y in X:

      (forall x. x <= y ==> f(x) <= y)  ===>  mu(f) <= y.

  Beweis: Betrachte die Teilmenge T := { z | z <= y }.
  T wird mit den gleichen binären Joins und Meets zu einem vollständigen Verband.
  (Achtung, aufpassen bei beliebigen Meets.)
  Nach Voraussetzung wird T von f bewahrt.
  Also existiert ein Fixpunkt mu(f|_T). Damit:

      mu(f) <= mu(f|_T) <= y.

  Im Nachhinein sieht man: Da mu(f) auch in T liegt, gilt sogar mu(f) = mu(f|_T).

* Habe X sogar eine Implikation (rechtsadjungiert zur Meetbildung).
  Dann gilt:

      (forall x. a wedge x <= y ==> a wedge f(x) <= y)  ===>  a wedge mu(f) <= y.

* Analoge Prinzipien gelten auch, wenn man mu(f)_{>= u} meint, den kleinsten
  Fixpunkt oberhalb eines Elements u mit u <= f(u).

      (forall x. u <= x <= y ==> f(x) <= y)  ===>  mu(f)_{>= u} <= y.

      (forall x. u <= x, a wedge x <= y ==> a wedge f(x) <= y)  ===>  a wedge mu(f)_{>= u} <= y.

* Sei phi : X --> Y ein monotoner Operator, der Suprema erhält.

  Dann gibt es ein phi_* : Y --> X mit

      x <= phi_*(y)  <==>  phi(x) <= y,

  nämlich

      phi_*(y) := sup { x' | phi(x') <= y }.

  Dann gilt für alle y in Y:

      (forall x. phi(x) <= y ==> phi(f(x)) <= y)  ===>  phi(mu(f)) <= y.

* Bessere Prinzipien für den größten Fixpunkt: POPL'13, The power of parameterization in
  coinductive proof. http://plv.mpi-sws.org/paco/


=== Komplexität der Schrödinger-Gleichung

http://arxiv.org/abs/1403.7686


=== Morphismenzoo

* Catamorphismus: eindeutiger Morphismus aus einer initialen Algebra heraus.
  mu(F) --> A

* Anamorphismus: eindeutiger Morphismus in eine finale Koalgebra hinein.
  A --> mu(F)

* Sei psi : A --> FA eine Koalgebra und phi : FB --> B eine Algebra. Dann
  ist hylo(phi, psi) = cata(phi) . ana(psi) : A --> B.

* Dann gibt es Histomorphismen und als aufgepimpte Version Dynamorphismen.
  Mit letzteren fängt man das Muster der dynamischen Programmierung ein.
  http://kodu.ut.ee/~eugene/jkmpc06.pdf


=== Minimalzahl Erzeuger und Relationen über homologische Methoden

Philippe Malbos, Samuel Mimram.
Homological Computations for Term Rewriting Systems.
http://math.univ-lyon1.fr/homes-www/malbos/Art/hcTRS.pdf


=== Durchbruch in der Erzeugung von Zufallszahlen

http://eccc.hpi-web.de/report/2015/119/


=== Kein Durchbruch in der Erzeugung von Zufallszahlen, aber trotzdem cool

http://web.eecs.umich.edu/~qstout/abs/AnnProb84.html

Suppose you have a coin and want to flip it to generate a random bit. However,
it may not be a fair coin, i.e., it may be that "heads" and "tails" are not
equally likely. How can you use this potentially biased coin to generate an
unbiased result? In particular, how can you do this when you don't know what,
if any, the coin's bias is?

Von Neumann gave a simple solution: flip the coin twice. If it comes up heads
followed by tails, then call the outcome HEAD. If it comes up tails followed by
heads, then call the outcome TAIL. Otherwise (i.e., two heads or two tails
occured) repeat the process. Throughout we assume that the flips are
independent, and in this case it is easy to show that von Neumann's procedure
simulates an unbiased coin, in that one is exactly as likely to get a HEAD
outcome as a TAIL outcome, no matter what the coin's bias is. Further, no
matter what the bias is (as long as it is not 0 nor 1), in finite expected time
an unbiased outcome will be achieved.


=== Makros, die besser komponierbar sind

http://okmij.org/ftp/Scheme/macros.html#ck-macros


=== Besondere Rolle der in Polynomialzeit berechenbaren Funktionen

* http://www.scottaaronson.com/papers/philos.pdf, Seite 19f.

* Eine Funktion f : N --> N liegt genau dann in FP, wenn f von einem
  Programm berechnet werden kann, dessen Korrektheit in Logik zweiter Ordnung
  (mit Komprehension auf positive quantorenfreie Formeln beschränkt) bewiesen
  werden kann.

* "Results like these provide further evidence—if any was needed—that
  polynomial-time computability is an extremely natural notion: a “wide target
  in conceptual space” that one hits even while aiming in purely logical
  directions."

* "Theorem (Girard '98): there is a consistent refinement of the sequent
  calculus with unrestricted comprehension but restricted contraction in which
  the provably total functions are precisely the polynomial time functions."

  http://therisingsea.org/notes/talk-twothings.pdf


=== Verbindungen zwischen Berechenbarkeit und Logik

* Die Sigma_1-Mengen natürlicher Zahlen sind genau die rekursiv aufzählbaren.
  Und auch genau die Mengen der n's, sodass eine diophantische Gleichung
  f(n, x_1,...,x_m) = 0 lösbar ist.


=== Unmöglichkeit

* If a language can interpret itself then it is not total.
  http://cstheory.stackexchange.com/a/24994/32151


=== Turing-Grade

https://en.wikipedia.org/wiki/Turing_degree

Turinggrade messen, wie schwer genau unschaffbar schwere Probleme sind.

* Ein Problem ist genau dann lösbar, wenn es Turinggrad 0 hat.
  Es ist genau dann äquivalent zum Halteproblem, wenn es Turinggrad 0' hat.

* Es gibt 2^{aleph_0} viele verschiedene Turinggrade. Es gibt mindestens
  eine Menge von Turinggraden derselben Größe, deren Elemente paarweise
  unvergleichbar sind.

* Es gibt minimale Grade über 0. Der Grad 0' ist aber nicht minimal.
  (Sozusagen ist die Kontinuumshypothese für Turinggrade falsch.)

* Jede abzählbare Partialordnung lässt sich in Ordnung der Turinggrade
  einbetten.
