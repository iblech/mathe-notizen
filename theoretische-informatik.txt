=== Obere Schranken für Gegenbeispiele und Beweise

Gustavo Lacerda.
Upper-Bounding Proof Length with the Busy Beaver.
http://arxiv.org/abs/1406.1808

Sehr einfach zu verstehen!


=== Notions of computability at higher types

http://cstheory.stackexchange.com/questions/1117/realizability-theory-difference-in-power-between-lambda-calculus-and-turing-mac
http://homepages.inf.ed.ac.uk/jrl/Research/notions1.pdf


=== Noethers Theorem aus "Theorems for free"

http://lambda-the-ultimate.org/node/5078

Robert Atkey
Conservation laws for free!

Invariance is of paramount importance in programming languages and in
physics. In programming languages, John Reynolds’ theory of relational
parametricity demonstrates that parametric polymorphic programs are
invariant under change of data representation, a property that yields
“free” theorems about programs just from their types. In physics, Emmy
Noether showed that if the action of a physical system is invariant
under change of coordinates, then the physical system has a conserved
quantity: a quantity that remains constant for all time. Knowledge of
conserved quantities can reveal deep properties of physical systems. For
example, the conservation of energy, which by Noether’s theorem is a
consequence of a system’s invariance under time-shifting.

In this paper, we link Reynolds’ relational parametricity with Noether’s
theorem for deriving conserved quantities. We propose an extension of
System Fω with new kinds, types and term constants for writing programs
that describe classical mechanical systems in terms of their
Lagrangians. We show, by constructing a relationally parametric model of
our extension of Fω, that relational parametricity is enough to satisfy
the hypotheses of Noether’s theorem, and so to derive conserved
quantities for free, directly from the polymorphic types of Lagrangians
expressed in our system.


=== Fixpunktsatz von Knaster--Tarski

* Sei X ein vollständiger Verband. Sei f : X --> X ein monotoner Operator.
  Dann besitzt f einen größten Fixpunkt, und diesen kann man konstruieren als

      u := sup M  mit  M := { v | v <= f(v) }.

  Zunächst ist klar, dass u existiert.
  Ferner M <= f(u), denn für v in M (also v <= u) gilt v <= f(v) <= f(u).
  Also auch u <= f(u). Somit u in M.
  Dann auch f(u) in M. Also f(u) <= u.
  Also ist u ein Fixpunkt.

  Ferner ist u der größte Fixpunkt. Sei v irgendein Fixpunkt von f.
  Dann v in M. Also v <= u.

* Den kleinsten Fixpunkt bekommt man so:

      u := inf M  mit  M := { v | f(v) <= v }.

  Zunächst ist klar, dass u existiert.
  Ferner f(u) <= M, denn für v in M (also v >= u) gilt f(u) <= f(v) <= v.
  Also auch f(u) <= u. Somit u in M.
  Dann auch f(u) in M. Also f(u) >= u.
  Also ist u ein Fixpunkt.

  Ferner ist u der kleinste Fixpunkt. Sei v irgendein Fixpunkt von f.
  Dann v in M. Also u <= v.

* Und hier noch eine Konstruktionsmöglichkeit für den kleinsten Fixpunkt,
  wenn f Suprema von aufsteigenden Folgen bewahrt:

      u := sup M  mit  M := { bot, f(bot), f^2(bot), ... }.

  Dann f(u) =Vor= sup { f(bot), f^2(bot), ... } = sup M = u.

  Ferner ist u kleinster Fixpunkt, denn ist v irgendein Fixpunkt, so zeigt man
  durch Induktion, dass M <= v. Also auch u <= v.

* Sei X ein vollständiger Verband. Sei f : X --> X ein monotoner Operator.
  Dann gilt für alle y in X:

      (forall x. x <= y ==> f(x) <= y)  ===>  mu(f) <= y.

  Beweis: Betrachte die Teilmenge T := { z | z <= y }.
  T wird mit den gleichen binären Joins und Meets zu einem vollständigen Verband.
  (Achtung, aufpassen bei beliebigen Meets.)
  Nach Voraussetzung wird T von f bewahrt.
  Also existiert ein Fixpunkt mu(f|_T). Damit:

      mu(f) <= mu(f|_T) <= y.

  Im Nachhinein sieht man: Da mu(f) auch in T liegt, gilt sogar mu(f) = mu(f|_T).

* Habe X sogar eine Implikation (rechtsadjungiert zur Meetbildung).
  Dann gilt:

      (forall x. a wedge x <= y ==> a wedge f(x) <= y)  ===>  a wedge mu(f) <= y.

* Analoge Prinzipien gelten auch, wenn man mu(f)_{>= u} meint, den kleinsten
  Fixpunkt oberhalb eines Elements u mit u <= f(u).

      (forall x. u <= x <= y ==> f(x) <= y)  ===>  mu(f)_{>= u} <= y.

      (forall x. u <= x, a wedge x <= y ==> a wedge f(x) <= y)  ===>  a wedge mu(f)_{>= u} <= y.

* Sei phi : X --> Y ein monotoner Operator, der Suprema erhält.

  Dann gibt es ein phi_* : Y --> X mit

      x <= phi_*(y)  <==>  phi(x) <= y,

  nämlich

      phi_*(y) := sup { x' | phi(x') <= y }.

  Dann gilt für alle y in Y:

      (forall x. phi(x) <= y ==> phi(f(x)) <= y)  ===>  phi(mu(f)) <= y.
