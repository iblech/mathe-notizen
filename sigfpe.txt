* http://blog.sigfpe.com/2008/01/type-that-should-not-be.html
* http://blog.sigfpe.com/2008/01/what-does-topology-have-to-do-with.html
* http://blog.sigfpe.com/2010/05/constructing-intermediate-values.html
* http://blog.sigfpe.com/2010/07/death-to-hydrae-or-denotational.html
* http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html
* http://blog.sigfpe.com/2006/11/yoneda-lemma.html
* As a reminder, if I have time, a Neighborhood of Infinity has a series of six
  posts on “Untangling with Continued Fractions”, 0 - 5. I think the idea is
  that you convert a rational tangle into a rational number, work out its
  continued fraction, which tells you how to untwist the tangle.

* http://blog.sigfpe.com/2014/05/types-and-two-approaches-to-problem.html
  In a statically typed language you can predict the type of an expression
  knowing the type of its parts. This means you can reason reliably about code
  while wearing the hide-the-value filter. This means that almost any
  programming problem can be split into two parts: a quotient problem where you
  forget about the values, and then problem of lifting a solution to the
  quotient problem to a solution to the full problem. Or to put that in more
  conventional language: designing your data and function types, and then
  implementing the code that fits those types.

* http://blog.sigfpe.com/2007/03/curious-rotational-memory-of-electron_31.html
  My crazy idea as a kid was this: if there were two ways to get from A to B,
  maybe the B you reached by taking either of the two routes were actually
  slightly different, even though they looked the same. I was actually more
  concerned with journeys from A to A. Suppose the kitchen has a door at each
  end and that you start in the bedroom, go down to the kitchen at one end,
  come out the other end, and return by a different path to the bedroom. How do
  you know this is the same bedroom? (I also admit I read a lot of science
  fiction as a kid.)

  Suppose instead you took a simpler path: you left the bedroom and went to
  another room and then returned by the path you went. If you had taken a piece
  of string and tied one end to the bedroom and walked this path playing out
  the string behind you as you went then when you returned to your bedroom you
  would have both ends of the string visible. You could then reel in the string
  from your journey, without letting go of the ends, and see that indeed, both
  ends were in fact the ends of the same string and so you had retuned to the
  start of your journey. But if you'd taken the round trip through the
  double-doored kitchen you wouldn't be able to pull the string tight and so
  you could no longer be sure.


Nicht sigfpe:

* http://de.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt


=== Freie Monaden

Ist f ein Funktor, so definiert

    data Free f a = Pure a | Impure (f (Free f a))

eine Monade -- die von f frei erzeugte Monade.

* Free Void = Maybe, wobei data Void r keine Konstruktoren hat.

* Free Identity a = a x N = State N a.

* Free (r,__) = a x [r].

Adjunktion: Für alle Funktoren f und Monaden m stehen

    Funktormorphismen f --> m

        in natürlicher Bijektion zu

    Monadenmorphismen Free f --> m.


=== Python

"Python-Code ist nur _lokal_ sehr gut lesbar."
