=== Cantor

* Sei phi : A --> P(A) eine Abbildung. Dann kann man explizit
  ein Element der Wertemenge angeben, das nicht getroffen wird, nämlich

      { x \in A | x \not\in phi(x) }.

  Also gibt es keine surjektive Abbildung A --> P(A).

* Auch kann man zeigen, dass es keine injektive Abbildung phi : P(A) --> A
  geben kann: Definiere

      U := { x \in A | \forall V \subseteq A: x \in V ==> x != phi(V) }
      x0 := phi(U).

  Dann folgt x0 \not\in U:

      Sei x0 in U. Speziell für V := U folgt dann, da x0 in U, dass x0 !=
      phi(U) ist. Das ist falsch.

  Andererseits kann man (unter Benutzung der Injektivität) zeigen, dass für
  alle V \subseteq A die Implikation

      x0 \in V ==> x0 != phi(V)

  gilt:

      Sei x0 in V. Angenommen x0 = phi(V). Dann folgt, da phi injektiv ist,
      dass U = V. Also liegt x0 in U. Das ist ein Widerspruch. Also x0 !=
      phi(V).

  Also gilt doch x0 \in U. Widerspruch.

* Eine Injektion N^N --> N kann es schon geben: etwa in Eff(STM).
  Damit gibt es in Eff(STM) auch eine Injektion 2^N --> N. Das ist kein
  Widerspruch zum Vorherigen, weil 2 != Omega.


=== Chaitin

* http://math.ucr.edu/home/baez/surprises.html

  There exists a constant L such that no string of bits has Kolmogorov
  complexity that provably exceeds L.


=== Unlösbare Probleme

Poonen.
Undecidable problems: a sampler.
http://www-math.mit.edu/~poonen/papers/sampler.pdf


=== Vollständigkeit

Benjamin Frot.
Gödel's Completeness Theorem and Deligne's Theorem.
http://arxiv.org/abs/1309.0389

Empfohlen von John Baez!


=== Naive Mengenkomprehension

* Russels Antinomie ist ja bekannt.

* Aber auch ohne Negation gibt es Paradoxa:
  http://www.logicmatters.net/resources/pdfs/gwt/GWT2f.pdf
  Seite 99


=== Gödel

* http://quantropy.org/14/1/godel.pdf

* http://rgheck.frege.org/pdf/notes/TheFixedPointTheorem.pdf

* http://goodmath.scientopia.org/2013/03/12/finally-gdels-proof-of-incompleteness/

* http://www.logicmatters.net/resources/pdfs/gwt/GWT2f.pdf

* http://jdh.hamkins.org/are-all-godel-sentences-equivalent/
  In einem gewissen Sinn sind alle Gödelsätze zueinander beweisbar äquivalent,
  da sie alle äquivalent sind zu Con(PA).

* Gödels Erster sagt: Ist PA konsistent, so ist G nicht beweisbar.

  Der Beweis von Gödels Erstem lässt sich formalisieren. So folgt:
  PA beweist Con(PA) --> neg Prov(G). Die Umkehrung ist sowieso beweisbar.
  Zudem ist G beweisbar äquivalent zu neg(Prov(G)). Also beweist PA,
  dass Con(PA) zu G äquivalent ist.

  Damit kann man Gödels Zweiten zeigen: Falls PA |- Con(PA), so PA |- G,
  aber dem ist nicht so.

  Das ganze gilt auch analog für HA.

  Fazit: PA |- (Con(PA) <-> neg Prov(#(Con(PA)))).

  In PA folgt automatisch, dass Prov(#(1=0)) und Prov(#(Con(PA))) äquivalent sind.
  Die analoge Aussage für HA folgt nicht automatisch. Stimmt sie trotzdem?

* Ein Beweis von Gödels Zweitem übers unexpected hanging paradox:
  http://www.ams.org/notices/201011/rtx101101454p.pdf

* Falls PA konsistent ist, so gibt es Theorien, die ihre Inkonsistenz beweisen,
  obwohl sie konsistent sind. (Sie sind dann nicht omega-konsistent.)

  Etwa ist PA + neg(Con(PA)) eine solche:
  https://golem.ph.utexas.edu/category/2011/09/the_inconsistency_of_arithmeti.html#c039574

* Auch in schwachen Metatheorien gibt es insofern sowas wie NN, als dass es
  sinnvoll ist, von NN |== A zu sprechen. Aber NN |== PA gilt eventuell nicht,
  wegen des in PA enthaltenen Induktionsaxioms oder wegen der in PA enthaltenen
  klassischen Logik. (Achtung, bedenke Tarski!)

* Das Diagonallemma besagt: Sei F(n) eine Aussageform. Dann gibt es
  eine Aussage A mit PA |- (A <-> F(#A)).

  Ein Beweis geht so. Definiere zunächst diag : NN --> NN durch
  diag(m) = #(B(m)), falls m die Kodierung einer Aussageform B(n) ist,
  und beliebig sonst. Es diag darstellbar durch eine Formel Diag(n,m)
  in PA, d.h. für alle natürlichen Zahlen n gilt

        PA |- forall y. Diag(n,y) <-> y = diag(n).

  Definiere die Aussageform B(n) := (exists y. Diag(n,y) wedge F(y)).
  Sei m = #(B(n)).

  Dann setze A := B(m). Es gilt diag(m) = #(B(m)) = #A.
  Dann: A -||- (exists y. Diag(m,y) wedge F(y)) -||- F(diag(m)) -||- F(#A).

  Geht alles konstruktiv und für HA statt PA. Einziger Punkt, bei dem ich mir
  nicht sicher bin, ist die Darstellung von diag durch eine Formel.

  Etwas einfacher schreibt sich das ganze so.

  Setze B(n) := F(diag(n)). Dabei ist nun "diag" das Funktionssymbol für die
  Funktion diag von oben.

  Dann m := #(B(n)) und A := B(m). Dann A -||- F(diag(m)) -||- F(#(B(m))) -||- F(#A).

  Auf deutsch lässt sich A so definieren: A = F(Gödelnummer derjenigen
  Zeichenkette, die man erhält, wenn man in der Zeichenkette "F(Gödelnummer, die
  man erhält, wenn man in derjenigen Zeichenkette, die durch n kodiert ist, die
  vorkommende Variable durch n ersetzt)" die vorkommende Variable durch die
  Gödelnummer dieser Zeichenkette ersetzt). https://mathoverflow.net/a/66405/31233

  Die Gödel-Aussage lautet: "Die Aussage, die man erhält, wenn man in der
  Aussage 'Die Aussage, die man erhält, wenn man in der Aussage x die
  vorkommende Variable durch die Gödelnummer dieser Aussage ersetzt, ist nicht
  beweisbar.' die vorkommende Variable durch die Gödelnummer dieser Aussage
  ersetzt, ist nicht beweisbar."

  Der Beweis zeigt noch etwas mehr: Nämlich, dass nicht zu PA zeigt,
  dass A zu Prov(#A) äquivalent ist, sondern auch, dass A tatsächlich zu
  Prov(#A) äquivalent ist. Das ist gut zu wissen, falls man nicht unterstellen
  möchte, dass PA sound ist. Denn damit unterstellt man ja gleich die
  Konsistenz von PA.

* Definiere Gödelnummerierung. Erhalte Aussageform Prov(n) mit

      NN |== Prov(#A)  genau dann, wenn  PA |- A

  für alle Aussagen A. Finde mit Diagonallemma Aussage A mit

      PA |- (A <-> neg Prov(#A)).

  Dann ist es nicht der Fall, dass PA A zeigt, sofern PA konsistent ist. Denn
  angenommen schon. Sei p ein Beweis. Dann auch PA |- Proof(p, #A).
  Insbesondere PA |- Prov(#A). Da auch PA |- Prov(A), folgt PA |- bot.

  Sofern PA sogar omega-konsistent ist, folgt auch, dass PA nicht neg(A) zeigt.

  In jedem Fall gilt NN |== A.

* Was gibt's konstruktiv zu sagen? Es sollte auch eine Aussageform Prov(n)
  mit

      NN |== ProvI(#A)  genau dann, wenn  HA |- A

  für alle Aussagen A geben. Diagonallemma sollte auch Bestand haben, es gibt
  also eine Aussage A wie oben. Auch der Rest lässt sich so wiederholen.

* Definiere Aussageform Prov^R(n) durch

      Prov^R(n) := (exists p. Proof(p,n) wedge (forall q. q <= p --> neg Proof(q, neg(n)))).

  Es gilt: Lässt sich A in PA beweisen, so zeigt PA auch Prov^R(#A), sofern PA
  konsistent ist. Denn sei p ein Beweis von A. Dann auch PA |- Proof(p, #A).
  Sei ferner q <= p. Dann ist q kein Beweis von neg(A), denn neg(A) ist unter
  der Konsistenzannahme nicht beweisbar. Es gilt dann auch PA |- neg Proof(q, #(neg(A))).
  Ganz sauber geht das wohl so:

      Es gibt eine primitiv-rekursive Funktion Beh, die die Gödelnummer der
      gezeigten Behauptung zurückliefert, falls sie mit der Gödelnummer eines
      korrekten Beweises aufgerufen wird, und die andernfalls eine designierte
      andere Zahl zurückliefert.

      Proof(r,n) ist definiert als Beh(r) = n.

      In unserem Kontext gilt Beh(q) != neg(#A).

      neg(Proof(q,neg(#A))) ist beweisbar äquivalent zu neg(Beh(q) = neg(#A)).
      Es sind Beh(q) und neg(#A) zwei konkrete verschiedene Zahlen. PA kann
      daher zeigen, dass sie nicht gleich sind.

  Insgesamt folgt PA |- forall q. q <= p --> neg Proof(q, neg(#A)), denn es
  das gilt das Lemma PA |- forall q. q <= p --> bigvee_{i=0}^p (q = i).

  Es gilt sogar ohne die Konsistenzannahme, dass aus PA |- A schon
  PA |- Prov^R(#A) folgt. Denn sei p ein Beweis von A. Dann auch PA |- Proof(p,#A).
  Sei nun q <= p. Es ist q ein Beweis von neg(A) oder nicht. Im ersten Fall
  zeigt PA also A und neg(A), somit bot, somit auch Prov^R(#A). Im zweiten Fall
  kann wie oben argumentiert werden.

  Das war alles konstruktiv. Außerdem gilt das alles konstruktiv auch für HA
  statt PA.

  Für die weitere Anwendung in HA muss man auch Folgendes nachweisen (*):
  Gelte HA |- neg(A). Dann nicht nur HA |- ProvI^R(#(neg(A))), sondern auch

      HA |- exists p. ProofI(p,neg(#A)) wedge (forall q. q <= p --> neg ProofI(q,#A)).
                                (schon klar wäre es mit neg(neg(#A)) hinten)

  Denn sei p die Nummer eines Beweises von neg(A). Dann HA |- ProofI(p,neg(#A)).
  Sei nun q <= p. Dann BehI(q) = A oder nicht. Im ersten Fall folgt also HA |- A,
  also HA |- bot, also HA |- neg(ProofI(q,#A)). Im zweiten Fall folgt das
  ebenfalls.

* Sei nun A eine Aussage mit PA |- (A <-> neg Prov^R(#A)).

  Dann lässt sich A nicht beweisen, sofern PA konsistent ist. Denn angenommen
  schon. Dann folgt PA |- Prov^R(#A). Andererseits PA |- neg(Prov^R(#A)). Also
  PA |- bot.

  Auch dies gilt alles auch für HA. Man muss dann natürlich ProvI^R verwenden.

  Im Übrigen gilt NN |== A. Denn das bedeutet einfach, dass Prov^R(#A) nicht
  stimmt. Angenommen Prov^R(#A). Dann insbesondere Proof(#A). Also PA |- A.
  Aber das stimmt ja nicht.

* Nun wollen wir zeigen, dass PA auch nicht neg(A) zeigt. Wenn NN ein Modell
  von PA ist, ist das klar: Denn angenommen PA |- neg(A). Dann auch NN |== neg(A).
  Das ist ein Widerspruch zu NN |== A.

  Rein syntaktisch geht es auch, nur unter der Annahme der Konsistenz, der
  Beweis auf https://en.wikipedia.org/wiki/Rosser%27s_trick ist gut. Habe auch
  geprüft, dass es wieder für HA durchgeht. Dazu benötigt man oben
  angesprochene Verfeinerung (*).

* Was passiert, wenn man in einer intuitionistischen Metatheorie mit
  antiklassischen Axiomen arbeitet? McCarty weiß Antwort:
  https://projecteuclid.org/download/pdf_1/euclid.ndjfl/1093635833

* Löbs Theorem: Genau dann ist Prov(#A) --> A ableitbar, wenn A es ist.

  Die Rückrichtung ist klar.

  Die Hinrichtung geht so: Finde mit dem Diagonallemma eine Aussage B
  mit PA |- (B <-> (Prov(#B) --> A)). Dann kann man einsehen, dass
  PA |- (Prov(#B) --> Prov(#A)). Insgesamt also PA |- B. Somit auch
  PA |- Prov(#B). Und damit PA |- A.

  Siehe
  http://www.michaelbeeson.com/teaching/StanfordLogic/Lecture15Slides.pdf,
  Folie 16. Geht alles auch konstruktiv für HA durch.

  Mit Kontraposition kann man das auch aus Gödels zweitem
  Unvollständigkeitssatz ableiten, aber das geht dann wohl nicht konstruktiv.
  http://web.mit.edu/24.242/www/2ndIncompleteness.pdf, Seite 11.

  Gödel 1 und 2 verallgemeinert "auf A statt bottom":

  Sei B eine Aussage mit PA |- (B <-> (Prov(#B) --> A)).

  Dann sehen wir: (PA |- A  ==>  A)  ===>  B.
  Denn B ist ja äquivalent zu (PA |- B) ==> A. (Hier geht ein, dass die
  Diagonalität nicht nur beweisbar ist, sondern auch stimmt!)
  Gelte also PA |- B. Wir wollen A zeigen. Da PA |- B, auch
  PA |- Prov(#B). Also PA |- A. Nach Voraussetzung somit A.

  Wenn wir das Argument formalisieren, sehen wir:

      PA |- (Prov(#A) --> A) --> B.

  Falls nun PA |- Prov(#A) --> A, so folgt PA |- B, also PA |- Prov(#B),
  also PA |- A.

* Ein Henkin-Satz behauptet seine eigene Beweisbarkeit:

      PA |- (H <-> Prov(#H)).

  Ein solcher ist nach Löbs Theorem beweisbar.

* http://gdz.sub.uni-goettingen.de/pdfcache/PPN379931524_0022/PPN379931524_0022___LOG_0008.pdf

* Man kann ja eigentliche alle Argumentationen in PA oder meinetwegen ZFC
  formalisieren. Aber es gibt eine große Klasse an wichtigen Ausnahmen:
  Argumente, die das Prinzip "Prov(#A) --> A" verwenden. Solche kann man nicht
  formalisieren, denn (vorausgesetzt PA ist konsistent), so ist das Prinzip
  nicht beweisbar (der Fall A = bottom ist Gödels zweiter
  Unvollständigkeitssatz).

  Sind Spezialfälle beweisbar? Für gewisse Arten von Aussagen? Aber eher nicht,
  oder?

  Die Umkehrung, A --> Prov(#A), ist (denke ich) für manche Aussagen beweisbar:
  Für Sigma-Aussagen (geometrische).

* Sei L vom Diagonallemma geliefert mit

      PA |- (L <-> (forall p. len(p) < f(n) --> neg Proof(p, #L))),

  wobei f eine rasch steigende Funktion ist.

  Dann gilt L, unter Annahme der Konsistenz von PA:

      L ist ja (auch, wenn PA nicht sound ist) äquivalent zu der genannten
      allquantifizierten Aussage. Sei also p eine Zahl mit len(p) < f(n).
      Angenommen, p ist ein Beweis von L. Dann weiß PA das auch, also folgt
      PA |- Proof(p, #L). Da PA |- L, folgt damit PA |- neg Proof(p, #L).
      Das ist ein Widerspruch zur Konsistenz.

  Internalisiert folgt: PA |- (Con(PA) --> L). Der das bezeugende Beweis ist
  kurz! (Er enthält n, und vielleicht die Beschreibung von f, aber er ist auf
  jeden Fall kürzer als f(n).)

* Warnung vor "die Axiome sind offensichtlich wahr": Hat man beim naiven
  Mengenkomprehensionsaxiom auch gedacht.

* Logical Dreams: https://arxiv.org/pdf/math/0211398.pdf

* Es gibt ein Polynom mit ganzzahligen (nicht nur natürlichzahligen)
  Koeffizienten, das genau dann eine Nullstelle in N^r (äquivalent: Z^r)
  besitzt, wenn PA inkonsistent ist.

  Denn die Menge X = { n >= 0 | n kodiert einen Beweis von bottom } ist
  rekursiv aufzählbar. Daher gibt es ein Polynom f(n,x_1,...,x_k) mit
  ganzzahligen Koeffizienten, sodass für alle n >= 0 gilt:

      n in X  <==>  exists x_1,...,x_k >= 0: f(n,x_1,...,x_k) = 0.

  Somit:

      PA inkonsistent  <==>  exists n: n in X  <==>  f besitzt Lösung in N^{k+1}.

  Ich weiß nicht, wie konstruktiv der Beweis des MRDP-Problems ist. Vermutlich
  kann man f schon hinschreiben. Damit man aus einer Lösung einen
  Inkonsistenzbeweis gewinnen könnte, würde schon

      neg neg (n in X)  <==  neg neg (exists x...)

  genügen. Ich weiß aber leider auch nicht, wie viel Konsistenzannahmen im
  Beweis des MRDP-Problems drinstecken.

* http://www.maths.ed.ac.uk/~mbooth/mrdp.pdf. Putnams Trick:

  Sei eine rekursiv aufzählbare Menge X mit 0 nicht in X gegeben. Nach MRDP
  gibt es ein Polynom f(n,x_1,...,x_k) mit (n in X <==> exists x: f(n,x) = 0).
  Indem wir f durch f^2 ersetzen, können wir davon ausgehen, dass alle
  Funktionswerte von f (an Tupeln natürlicher Zahlen) nichtnegativ sind. Das
  Polynom Q(n,x) = x * (1 - f(n,x)) hat nun folgende Eigenschaft:

      Die nichtnegativen Funktionswerte von Q(n,x), wobei n und x alle
      natürliche Zahlen ablaufen, sind genau die Elemente aus X.

* Sei P folgendes Programm ("das universelle Programm"):

      Suche systematisch alle HA-Beweise nach einem Beweis der Form "Programm P
      gibt nicht die Liste x_1,...,x_k aus" ab. Sobald ein solcher Beweis
      gefunden wurde, gib die Liste x_1,...,x_k aus.

  Ist HA konsistent, so gilt für jede Liste xs: HA beweist nicht, dass P nicht
  die Liste xs ausgibt. Denn angenommen schon. Dann gibt es auch irgendeine
  erste Liste ys, für die HA beweist, dass P nicht die Liste ys ausgibt. Also
  gibt P ys aus. Das kann HA auch beweisen. Also zeigt HA bottom.

  (Alternativer Beweis: Denn angenommen schon. Dann hält P. Somit gibt es eine
  Liste ys, sodass HA beweist, dass P nicht ys ausgibt, und sodass P trotzdem ys
  ausgibt. HA beweist dann auch, dass P ys ausgibt. Also zeigt HA bottom.)

  Somit ist HA + (P gibt Liste xs aus) konsistent, falls HA es ist.

  "Somit" gibt es ein Modell von HA + (P gibt Liste xs aus). In diesem gibt P
  natürlich die Liste xs aus (nach Axiom). Innerhalb dieses Modells gibt es
  also einen HA-Beweis (mit Nichtstandardlänge), dass P nicht xs ausgibt.


=== Parikh

* Es gibt Aussagen, die nur einen langen Beweis haben, aber einen kurzen Beweis,
  dass sie einen Beweis haben.

  Nämlich "Diese Aussage besitzt keinen Beweis von weniger als n Zeichen",
  wobei n eine natürliche Zahl ist, die wir so hochschrauben können, wie wir
  möchten.

  Unter der Annahme, dass PA konsistent ist, kann es nicht sein, dass diese
  Aussage einen Beweis von weniger als n Zeichen besitzt. Denn wenn schon, dann
  beweist PA einen Widerspruch.

  Wir können alle Beweise von weniger als n Zeichen durchgehen. Dabei werden
  wir unter der Konsistenzannahme keinen Beweis der Aussage finden. Diese
  Überlegung kann PA auch beweisen. Damit hat sie die Beweisbarkeit der Aussage
  bewiesen.

  Siehe etwa http://www.math.ucla.edu/~asl/bsl/0903/0903-004.ps,
  Yanofsky: A Universal Approach to Self-Referential Paradoxes,
  Incompleteness and Fixed Points.

  Originalartikel: https://www.jstor.org/stable/pdf/2269958.pdf.


=== Inkonsistenz von PA

* https://www.math.ias.edu/vladimir/sites/math.ias.edu.vladimir/files/2010_09_25_slides.pdf

  Problem mit üblichem "Beweis", dass PA konsistent ist: Nicht alle Teilmengen,
  die über Formeln in PA definiert werden, haben eine "Bedeutung": Für manche
  gilt für keine Zahl, dass beweisbar ist, dass sie in der Menge liegt, oder
  dass beweisbar ist, dass sie nicht in der Menge liegt.

* McLarty in
  https://artscimedia.case.edu/wp-content/uploads/2013/07/14182256/General-talk.pdf:

  "I point I owe to John Mayberry: we have only ever applied
  induction for conditions φ that make sense.

  If the formalism conceals an inconsistency we should expect it to
  lie in conditions φ with no apparent sense."


=== Finitistisch akzeptables Schließen

... wird laut manchen Leuten formalisiert durch PRA (primitiv-rekursive
Arithmetik). Manchmal genügt sogar ERA, das ist wie Peano-Arithmetik, aber mit
dem Induktionsprinzip eingeschränkt auf elementar berechenbare Prädikate.

http://www.icm2006.org/proceedings/Vol_II/contents/ICM_Vol_2_03.pdf


=== Definierbarkeit

* Klar, es gibt Tarskis Resultat.

* Man kann aber in Mengenlehre, für jede Menge U, definieren, wann
  eine Formel (der Mengenlehre), kodiert als natürliche Zahl, U-relativiert
  gilt. Dazu muss man halt einen Interpreter schreiben. Dessen Typ ist sowas
  wie

      N --> Omega^Env,

  wobei Env die Menge der endlichen Listen von Elementen aus U ist. In ZF kann
  man ja bekanntlich rekursive Definitionen treffen.

* Wenn man dieses Verfahren auch für das Universum U, die Klasse aller Mengen,
  durchführen möchte, so gibt es natürlich ein Problem (wie von Tarski
  vorhergesehen). Zunächst gibt es keine passende Menge Env. Das ist aber noch
  nicht an sich ein Problem, denn man muss ja in ZF nicht Zielmengen von
  Abbildungen angeben. Allerdings muss ja f(#top) sowas sein wie

      const {*}, d.h.
          { <e, {*}> | e aus Env },

  und das existiert auch nicht.

* Eine Menge M heißt genau dann definierbar rel X, wenn es eine Formel phi
  von Mengenlehre gibt, sodass M = { z in X | phi gilt rel X für z }.
  (Man kann die Definition nicht derart ausweiten, dass auch nicht-Teilmengen
  von X eine Chance hätten, definierbar rel X zu sein.)

* Def(X) ist die Menge aller rel X definierbaren Teilmengen von X.

  Damit dieses Konzept nicht sehr pervers ist, muss X zumindest sowas wie
  transitiv sein. Zum Beispiel sollte ja die Teilmenge der positiven
  natürlichen Zahlen rel N definierbar sein. Das stimmt schon auch, ist aber
  nicht völlig trivial. Denn die rel-U-Extension von "n ist positiv",
  ausgeschrieben "0 in n" bzw. "exists z. z in n wedge forall y. neg (y in z)"
  lautet:

      exists z in N.
          z in n  wedge
              forall y in N. neg (y in z).

  Das besagt also nicht, dass 0 (die leere Menge) ein Element von n ist. Nur,
  dass eine Menge z ein Element von n ist, welche keine natürlichen Zahlen
  enthält. Wegen der Transitivität von N folgt dann aber, dass z die leere
  Menge ist. Denn sei y in z. Dann y in z in N. Also y in N. Also Widerspruch.


=== Wahrheit vs. Beweisbarkeit

* "Because it’s the case that if a number-theoretic statement is true, then its
  witnessing functions exist, we might hope that it would be the case that if a
  number-theoretic statement is provable, then its witnessing functions are
  computable, that is, that we could extract a computer program for the
  witnessing functions from the proof."
  https://xorshammer.com/2008/08/13/kreisels-no-counterexample-interpretation/

  Aber so naiv stimmt es natürlich nicht: Die Aussage "für alle n gibt es ein m
  sodass die n-te Turingmaschine nach m Schritten hält oder niemals hält" ist
  beweisbar in Peano-Arithmetik, aber besitzt keinen berechenbaren Zeugen.


=== Quantorenelimination

* Quantorenelimination ist bei der Theorie algebraisch abgeschlossener Körper
  möglich. Idee: Ersetze zwei Gleichungen

      f(x) = 0  und  g(x) = 0

  mit f(x) = a x^n + ..., g(x) = b x^m + ..., n >= m, durch

      (b  = 0 und (f(x) = 0 und g(x)-bx^m = 0)) oder
      (b != 0 und (b*f(x) - a*x^{n-m}*g(x) = 0 und g(x) = 0)).

  Die neu auftretenden Gleichungen haben geringeren Grad. Schlussendlich
  bleiben nur Gleichungen zwischen Konstanten übrig (die Variable x wurde also
  eliminiert) und Gleichungssysteme bestehend aus einer einzelnen Gleichung
  übrig (welche wegen der Voraussetzung der algebraischen Abgeschlossenheit
  stets lösbar sind). Dann kann man rekursiv mit den in den Konstanten
  versteckten weiteren Variablen weitermachen.

* Quantorenelimination zieht nach sich: Bilder quantorfrei definierter Mengen
  unter definierbaren Abbildungen sind wieder quantorfrei definierbar.

* Auch die Theorie reell abgeschlossener Körper besitzt Quantorenelimination.
  Daher sind Bilder semialgebraischer Mengen unter polynomiellen Abbildungen
  wieder semialgebraisch.

* Inwieweit ist Chevalleys Theorem eine Verallgemeinerung?

* Ting Zhang. A survey of quantifier elimination: syntactic and semantic
  approaches. http://theory.stanford.edu/~tingz/talks/qe.ps

* http://homepages.math.uic.edu/~marker/orsay/orsay2.pdf

* Quantifier elimination in C*-algebras. http://arxiv.org/abs/1502.00573

* Zahlentheoretische Aussagen, die nur die Quantoren "für fast alle n"
  und "es gibt unendlich viele n" verwenden, sind entscheidbar.
  Weil man auch R statt N verwenden kann.
  https://xorshammer.com/2008/08/25/almost-a-number-theoretic-miracle/


=== Analytische Hierarchie

Achtung, hier klassische Logik benutzt!

* Jede Pi_1^1-Aussage ist äquivalent zu einer Aussage der Form

      forall f : N --> N. exists m : N. R(n, f^(m)),

  wobei R ein rekursives Prädikat ist.
  Dabei ist f^ die "course of values"-Funktion, also f^(n) = (f(0),...,f(n-1)).

  Siehe: Cor. IV.2.10 in /Classical Recursion Theory/ von Odifreddi.

  (Wenn man Mengenquantoren statt Funktionsquantoren verwendet, muss man zwei
  Zahlquantoren verwenden. Stimmt das?)

* Eine Menge X natürlicher Zahlen ist genau dann eine Pi_1^1-Menge,
  wenn es eine rekursive Folge (T_n)_n rekursiver Bäume mit

      n in X  <==>  T_n ist fundiert

  gibt.

  Die Richtung "<==" ist klar, denn die Bedingung, dass T_n fundiert ist, ist
  eine Pi_1^1-Bedingung.

  Zur Richtung "==>" nutzen wir aus, dass die Menge X von der Form
  X = { n | forall f. exists m. R(n, f^(m)) } ist und definieren den Baum T_n
  so: Eine Folge xs von natürlichen Zahlen soll genau dann zum Baum gehören,
  wenn für jedes echte Suffix ys von xs die Aussage R(n, ys) falsch ist.

  Die Blätter des Baums geben also Plätze an, bei denen R(n, __) das erste Mal
  gilt.

* Eine analoge Aussage gibt es mit fundierten Ordnungen statt fundierten
  Bäumen.

* Mehr steht zur arithmetischen und analytischen Hierarchie in:

  * Beklemishev: Provability, Computability and Reflection
  * Grzegorczyk: An Outline of Mathematical Logic: Fundamental Results and
    Notions Explained

* https://xorshammer.com/2016/05/14/the-arithmetic-hierarchy-meets-the-real-world/


=== Temporale Logik

* Diodoreanische Modalität in Minkowski-Raumzeit (in Goldblatts Buch)


=== Induktive Logik

https://books.google.it/books?id=oxxaRUjhD_QC&printsec=frontcover#v=onepage&q&f=false
Handbook of the History of Logic: Inductive logic
herausgegeben von Dov M. Gabbay, John Hayden


=== Russel konstruktiv statt imprädikativ

http://staff.math.su.se/palmgren/CERRTT.pdf


=== Funktionssymbole

Folgende drei Theorien zeigen dieselben Formeln, die in der Sprache von HA
formuliert werden können:

1. HA

2. HA ergänzt um je ein Funktionssymbol für jeden Aufbau einer
primitiv-rekursiven Funktion, ergänzt um Axiome für das Funktionssymbol, welche
sich aus dem Aufbau der primitiv-rekursiven Funktion ergeben.

3. HA ergänzt um je ein Funktionssymbol für jede primitiv-rekursive Funktion,
ergänzt um Axiome für das Funktionssymbol, welche sich aus allen möglichen
Aufbauten der primitiv-rekursiven Funktion ergeben. Hier geht ein Lemma ein,
nämlich dass HA die Äquivalenz von Funktionen darstellenden Formeln zeigen
kann, sofern die Funktionen gleich sind.

Hier ein paar Details zu primitiv-rekursiven Funktionen und Co.

* Die Klasse der rekursiven Funktionen ist die kleinste Klasse von Funktionen
  N^k --> N, die die konstante Nullfunktion, die Nachfolgerfunktion und die
  Projektionsfunktionen enthält und abgeschlossen unter Komposition, primitiver
  Rekursion und regulärer Minimierung ist (unbeschränkte Minimierung über eine
  Relation, von der in der Metatheorie bekannt ist, dass sie erfüllt ist).

  Man kann aber auf die Zutat der primitiven Rekursion verzichten, sofern man
  im Gegenzug Addition, Multiplikation und (x,y) |-> delta_{x,y} aufnimmt.
  Das zeigt man mit der unten beschriebenen beta-Funktion:

  Sei h durch primitive Rekursion definiert:

      h(0,    zvec) = f(zvec)
      h(s(n), zvec) = g(n, h(n,zvec), zvec),

  wobei wir von f und g schon wissen, dass sie nur aus den genannten Zutaten
  aufgebaut sind.

  Dann definieren wir:

      H(n, zvec) = mu d.
          beta(d,0) = f(zvec) wedge
              forall i < n: beta(d,i+1) = g(i, beta(d,i), zvec).

  Dann h(n, zvec) = beta(H(n,zvec), n).

* Jede rekursive Funktion f ist in Q (und wohl auch sowas wie IQ,
  intuitionistische Q-Arithmetik) darstellbar. Das bedeutet, dass es eine
  Formel A(x,y) gibt, sodass für jedes x

      Q |- forall y. A(x,y) <--> y = f(x)

  gilt. (Dabei kann x auch Abkürzung für "x_1, ..., x_n" sein. Je zwei solche
  Formeln sind zueinander beweisbar äquivalent. Oder nicht? Zumindest hat man
  für jedes x, dass Q |- forall y. A(x,y) <--> A'(x,y). Das genügt aber nicht.
  Betrachte etwa die Formeln (beide im Kontext n:N) "n ist kein Beweis von
  bottom und "top". Für jedes Numeral n sind die beiden Formeln beweisbar
  äquivalent (infinitistische Metalogik vorausgesetzt). Aber sie sind nicht
  selbst beweisbar äquivalent. Das würde nämlich heißen, dass Q (oder was auch
  immer) seine Konsistenz zeigt.)

  Das folgt, da die Zutaten auf der zweiten Zutatenliste oben alle darstellbar
  sind.

  Ich glaube, dass HA noch etwas mehr kann: Zeigen, dass die so definierten
  Formeln zu primitiv-rekursiven Funktionen wirklich funktional sind, d.h.
  zeigen:

      HA |- forall x. exists! y. A(x,y).

  Für beliebige Funktionen gilt das sicher nicht. Zum Beispiel nicht für
  diejenige Funktion, die einer Zahl n die Länge von Goodstein(n) zuordnet.
  Das ist eine berechenbare Funktion!

  Das sollte so gehen: Ist für die Grundfunktionen klar. Bleibt nur primitive
  Rekursion. Sei also h über primitive Rekursion gegeben:

      h(0,    zvec) = f(zvec)
      h(s(n), zvec) = g(n, h(n,zvec), zvec),

  Dann zeigen wir jetzt die Funktionalität mittels Induktion über n.

  Der Induktionsanfang ist klar. Wir wissen ja schon, dass h dargestellt werden
  kann, und für das Numeral 0 haben wir Funktionalität.

  Nun der Induktionsschritt. Wir wissen

      exists! y. n h y

  und wollen zeigen:

      exists! v. (n+1) h v.

  Dabei jeweils die Parameter zvec unterdrückt.

  Zur Existenz: Finde y mit n h y. Finde v mit (n,y) g v. Dann (n+1) h v.
  Hier muss man sich etwas in die beta-Funktion einwühlen!

  Zur Eindeutigkeit: ...

* Es gilt auch die Umkehrung: Ist f in Q (oder IQ) durch eine Formel A
  darstellbar, so ist f berechenbar. Denn f(n) kann man wie folgt berechnen:
  Gehe alle Beweise von Q durch, bis ein Beweis einer Aussage der Form A(n,y)
  auftritt. Gib dann y zurück. Dieses Verfahren terminiert nach Voraussetzung.
  Sofern man unterstellt, dass Q konsistent ist, ist der Rückgabewert auch
  gerade f(n).

* Es gibt eine Funktion beta : N^2 --> N, sodass für jede Folge (a_0,...,a_n)
  eine Zahl d existiert, sodass beta(d,i) = a_i für i <= n, und sodass beta
  aus den Grundfunktionen und regulärer Minimierung (aber nicht primitiver
  Rekursion) hervorgeht.

  Nutze chinesischen Restsatz für hinreichend große Moduli und eine
  Paarungsfunktion, um neben der so erhaltenen Zahl auch eine weitere Zahl zu
  kodieren, aus der die Moduli extrahiert werden können.

  Genauer geht das so.

  Zunächst können wir die Paarungsfunktion J(x,y) = (x+y) (x+y+1) / 2 + x
  definieren. Dazu braucht's nur reguläre Minimierung: J(x,y) ist das kleinste z,
  sodass (x+y)*(x+y+1) + 2*x = 2z ist.

  Die Projektionen gehen auch:

      K(z) = mu x. exists y <= z. z = J(x,y),
      L(z) = mu y. exists x <= z. z = J(x,y).

  Es gilt dann K(J(x,y)) = x, L(J(x,y)) = y für alle x, y.

      Prelude> mapM_ print [ [ j x y | x <- [0..5] ] | y <- [0..5] ]
      [0,2,5,9,14,20]
      [1,4,8,13,19,26]
      [3,7,12,18,25,33]
      [6,11,17,24,32,41]
      [10,16,23,31,40,50]
      [15,22,30,39,49,60]

  Dann definieren wir:

      beta*(d0, d1, i) = rem(1 + (i+1) d1, d0)  und
      beta(d, i) = beta*(K(d), L(d), i).

  Sind nun Zahlen a_0, ..., a_n gegeben, so setzen wir

      j  := max { n, a_0, ..., a_n } + 1,
      d1 := j!,
      d0 so, dass d0 = a_i mod (1 + (i+1) d1) (existiert eindeutig).

Siehe: Um Seite 85 von
http://people.ucalgary.ca/~rzach/static/open-logic/courses/phil479/phil479-screen.pdf.


=== Lineare Logik

* Ein Grund "wieso": Weil automatisches Beweisen praktikabel wird.
  https://blog.plover.com/math/logic/cut-rule.html


=== Beweisprädikate, die die HBL-Bedingungen nicht erfüllen

* "x besitzt einen schnittregelfreien Beweis"

* https://mathoverflow.net/a/231011/31233


=== Wie viele Beweise besitzt eine Aussage?

* Jost: Wenn die Behauptung hinreichend weit von den Voraussetzungen
  entfernt ist, dann kann sie verschiedene Beweise zulassen.

* FTA ist wohl ein Beispiel.

* Einfachheit und Länge von Beweisen:
  http://www.phil.uu.nl/~iemhoff/Mijn/Papers/simplicity.pdf


=== Robinson-Arithmetik Q

* Beweist konkrete Aussagen (etwa jede Instanz der binomischen Formel),
  aber kaum allgemeine Aussagen.

* Ein Modell von Q ist die Menge all derjenigen Polynome aus Z[X],
  deren Leitkoeffizient (sofern vorhanden) positiv ist, mit der üblichen
  Polynomaddition und -multiplikation und +1 als Nachfolgeroperation.


=== Nächste Schritte

* Kann man explizit x, y mit phi(x) != phi(y) angeben?

* http://golem.ph.utexas.edu/category/2012/12/universe_polymorphism_and_typi.html

* https://arxiv.org/pdf/1504.03380.pdf
