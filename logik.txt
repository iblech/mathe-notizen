=== Cantor

* Sei phi : A --> P(A) eine Abbildung. Dann kann man explizit
  ein Element der Wertemenge angeben, das nicht getroffen wird, nämlich

      { x \in A | x \not\in phi(x) }.

  Also gibt es keine surjektive Abbildung A --> P(A).

* Auch kann man zeigen, dass es keine injektive Abbildung phi : P(A) --> A
  geben kann: Definiere

      U := { x \in A | \forall V \subseteq A: x \in V ==> x != phi(V) }
      x0 := phi(U).

  Dann folgt x0 \not\in U:

      Sei x0 in U. Speziell für V := U folgt dann, da x0 in U, dass x0 !=
      phi(U) ist. Das ist falsch.

  Andererseits kann man (unter Benutzung der Injektivität) zeigen, dass für
  alle V \subseteq A die Implikation

      x0 \in V ==> x0 != phi(V)

  gilt:

      Sei x0 in V. Angenommen x0 = phi(V). Dann folgt, da phi injektiv ist,
      dass U = V. Also liegt x0 in U. Das ist ein Widerspruch. Also x0 !=
      phi(V).

  Also gilt doch x0 \in U. Widerspruch.

* Eine Injektion N^N --> N kann es schon geben: etwa in Eff(STM).
  Damit gibt es in Eff(STM) auch eine Injektion 2^N --> N. Das ist kein
  Widerspruch zum Vorherigen, weil 2 != Omega.


=== Chaitin

* http://math.ucr.edu/home/baez/surprises.html

  There exists a constant L such that no string of bits has Kolmogorov
  complexity that provably exceeds L.


=== Unlösbare Probleme

Poonen.
Undecidable problems: a sampler.
http://www-math.mit.edu/~poonen/papers/sampler.pdf


=== Vollständigkeit

Benjamin Frot.
Gödel's Completeness Theorem and Deligne's Theorem.
http://arxiv.org/abs/1309.0389

Empfohlen von John Baez!


=== Naive Mengenkomprehension

* Russels Antinomie ist ja bekannt.

* Aber auch ohne Negation gibt es Paradoxa:
  http://www.logicmatters.net/resources/pdfs/gwt/GWT2f.pdf
  Seite 99


=== Gödel

* http://quantropy.org/14/1/godel.pdf

* http://rgheck.frege.org/pdf/notes/TheFixedPointTheorem.pdf

* http://goodmath.scientopia.org/2013/03/12/finally-gdels-proof-of-incompleteness/

* http://www.logicmatters.net/resources/pdfs/gwt/GWT2f.pdf

* http://jdh.hamkins.org/are-all-godel-sentences-equivalent/
  In einem gewissen Sinn sind alle Gödelsätze zueinander beweisbar äquivalent,
  da sie alle äquivalent sind zu Con(PA).

* Gödels Erster sagt: Ist PA konsistent, so ist G nicht beweisbar.

  Der Beweis von Gödels Erstem lässt sich formalisieren. So folgt:
  PA beweist Con(PA) --> neg Prov(G). Die Umkehrung ist sowieso beweisbar.
  Zudem ist G beweisbar äquivalent zu neg(Prov(G)). Also beweist PA,
  dass Con(PA) zu G äquivalent ist.

  Damit kann man Gödels Zweiten zeigen: Falls PA |- Con(PA), so PA |- G,
  aber dem ist nicht so.

  Das ganze gilt auch analog für HA.

  Fazit: PA |- (Con(PA) <-> neg Prov(#(Con(PA)))).

  In PA folgt automatisch, dass Prov(#(1=0)) und Prov(#(Con(PA))) äquivalent sind.
  Die analoge Aussage für HA folgt nicht automatisch. Stimmt sie trotzdem?

* Ein Beweis von Gödels Zweitem übers unexpected hanging paradox:
  http://www.ams.org/notices/201011/rtx101101454p.pdf

* Falls PA konsistent ist, so gibt es Theorien, die ihre Inkonsistenz beweisen,
  obwohl sie konsistent sind. (Sie sind dann nicht omega-konsistent.)

  Etwa ist PA + neg(Con(PA)) eine solche:
  https://golem.ph.utexas.edu/category/2011/09/the_inconsistency_of_arithmeti.html#c039574

* Auch in schwachen Metatheorien gibt es insofern sowas wie NN, als dass es
  sinnvoll ist, von NN |== A zu sprechen. Aber NN |== PA gilt eventuell nicht,
  wegen des in PA enthaltenen Induktionsaxioms oder wegen der in PA enthaltenen
  klassischen Logik.

* Das Diagonallemma besagt: Sei F(n) eine Aussageform. Dann gibt es
  eine Aussage A mit PA |- (A <-> F(#A)).

  Ein Beweis geht so. Definiere zunächst diag : NN --> NN durch
  diag(m) = #(B(m)), falls m die Kodierung einer Aussageform B(n) ist,
  und beliebig sonst. Es diag darstellbar durch eine Formel Diag(n,m)
  in PA, d.h. für alle natürlichen Zahlen n gilt

        PA |- forall y. Diag(n,y) <-> y = diag(n).

  Definiere die Aussageform B(n) := (exists y. Diag(n,y) wedge F(y)).
  Sei m = #(B(n)).

  Dann setze A := B(m). Es gilt diag(m) = #(B(m)) = #A.
  Dann: A -||- (exists y. Diag(m,y) wedge F(y)) -||- F(diag(m)) -||- F(#A).

  Geht alles konstruktiv und für HA statt PA. Einziger Punkt, bei dem ich mir
  nicht sicher bin, ist die Darstellung von diag durch eine Formel.

  Etwas einfacher schreibt sich das ganze so.

  Setze B(n) := F(diag(n)). Dabei ist nun "diag" das Funktionssymbol für die
  Funktion diag von oben.

  Dann m := #(B(n)) und A := B(m). Dann A -||- F(diag(m)) -||- F(#(B(m))) -||- F(#A).

  Auf deutsch lässt sich A so definieren: A = F(Gödelnummer derjenigen
  Zeichenkette, die man erhält, wenn man in der Zeichenkette "F(Gödelnummer, die
  man erhält, wenn man in derjenigen Zeichenkette, die durch n kodiert ist, die
  vorkommende Variable durch n ersetzt)" die vorkommende Variable durch die
  Gödelnummer dieser Zeichenkette ersetzt). https://mathoverflow.net/a/66405/31233

  Die Gödel-Aussage lautet: "Die Aussage, die man erhält, wenn man in der
  Aussage 'Die Aussage, die man erhält, wenn man in der Aussage x die
  vorkommende Variable durch die Gödelnummer dieser Aussage ersetzt, ist nicht
  beweisbar.' die vorkommende Variable durch die Gödelnummer dieser Aussage
  ersetzt, ist nicht beweisbar."

  Der Beweis zeigt noch etwas mehr: Nämlich, dass nicht zu PA zeigt,
  dass A zu Prov(#A) äquivalent ist, sondern auch, dass A tatsächlich zu
  Prov(#A) äquivalent ist. Das ist gut zu wissen, falls man nicht unterstellen
  möchte, dass PA sound ist. Denn damit unterstellt man ja gleich die
  Konsistenz von PA.

* Definiere Gödelnummerierung. Erhalte Aussageform Prov(n) mit
  
      NN |== Prov(#A)  genau dann, wenn  PA |- A

  für alle Aussagen A. Finde mit Diagonallemma Aussage A mit

      PA |- (A <-> neg Prov(#A)).

  Dann ist es nicht der Fall, dass PA A zeigt, sofern PA konsistent ist. Denn
  angenommen schon. Sei p ein Beweis. Dann auch PA |- Proof(p, #A).
  Insbesondere PA |- Prov(#A). Da auch PA |- Prov(A), folgt PA |- bot.

  Sofern PA sogar omega-konsistent ist, folgt auch, dass PA nicht neg(A) zeigt.

  In jedem Fall gilt NN |== A.

* Was gibt's konstruktiv zu sagen? Es sollte auch eine Aussageform Prov(n)
  mit

      NN |== ProvI(#A)  genau dann, wenn  HA |- A

  für alle Aussagen A geben. Diagonallemma sollte auch Bestand haben, es gibt
  also eine Aussage A wie oben. Auch der Rest lässt sich so wiederholen.

* Definiere Aussageform Prov^R(n) durch

      Prov^R(n) := (exists p. Proof(p,n) wedge (forall q. q <= p --> neg Proof(q, neg(n)))).

  Es gilt: Lässt sich A in PA beweisen, so zeigt PA auch Prov^R(#A), sofern PA
  konsistent ist. Denn sei p ein Beweis von A. Dann auch PA |- Proof(p, #A).
  Sei ferner q <= p. Dann ist q kein Beweis von neg(A), denn neg(A) ist unter
  der Konsistenzannahme nicht beweisbar. Es gilt dann auch PA |- neg Proof(q, #(neg(A))).
  Ganz sauber geht das wohl so:

      Es gibt eine primitiv-rekursive Funktion Beh, die die Gödelnummer der
      gezeigten Behauptung zurückliefert, falls sie mit der Gödelnummer eines
      korrekten Beweises aufgerufen wird, und die andernfalls eine designierte
      andere Zahl zurückliefert.

      Proof(r,n) ist definiert als Beh(r) = n.

      In unserem Kontext gilt Beh(q) != neg(#A).

      neg(Proof(q,neg(#A))) ist beweisbar äquivalent zu neg(Beh(q) = neg(#A)).
      Es sind Beh(q) und neg(#A) zwei konkrete verschiedene Zahlen. PA kann
      daher zeigen, dass sie nicht gleich sind.

  Insgesamt folgt PA |- forall q. q <= p --> neg Proof(q, neg(#A)), denn es
  das gilt das Lemma PA |- forall q. q <= p --> bigvee_{i=0}^p (q = i).

  Es gilt sogar ohne die Konsistenzannahme, dass aus PA |- A schon
  PA |- Prov^R(#A) folgt. Denn sei p ein Beweis von A. Dann auch PA |- Proof(p,#A).
  Sei nun q <= p. Es ist q ein Beweis von neg(A) oder nicht. Im ersten Fall
  zeigt PA also A und neg(A), somit bot, somit auch Prov^R(#A). Im zweiten Fall
  kann wie oben argumentiert werden.

  Das war alles konstruktiv. Außerdem gilt das alles konstruktiv auch für HA
  statt PA.

  Für die weitere Anwendung in HA muss man auch Folgendes nachweisen (*):
  Gelte HA |- neg(A). Dann nicht nur HA |- ProvI^R(#(neg(A))), sondern auch

      HA |- exists p. ProofI(p,neg(#A)) wedge (forall q. q <= p --> neg ProofI(q,#A)).
                                (schon klar wäre es mit neg(neg(#A)) hinten)

  Denn sei p die Nummer eines Beweises von neg(A). Dann HA |- ProofI(p,neg(#A)).
  Sei nun q <= p. Dann BehI(q) = A oder nicht. Im ersten Fall folgt also HA |- A,
  also HA |- bot, also HA |- neg(ProofI(q,#A)). Im zweiten Fall folgt das
  ebenfalls.

* Sei nun A eine Aussage mit PA |- (A <-> neg Prov^R(#A)).

  Dann lässt sich A nicht beweisen, sofern PA konsistent ist. Denn angenommen
  schon. Dann folgt PA |- Prov^R(#A). Andererseits PA |- neg(Prov^R(#A)). Also
  PA |- bot.

  Auch dies gilt alles auch für HA. Man muss dann natürlich ProvI^R verwenden.

  Im Übrigen gilt NN |== A. Denn das bedeutet einfach, dass Prov^R(#A) nicht
  stimmt. Angenommen Prov^R(#A). Dann insbesondere Proof(#A). Also PA |- A.
  Aber das stimmt ja nicht.

* Nun wollen wir zeigen, dass PA auch nicht neg(A) zeigt. Wenn NN ein Modell
  von PA ist, ist das klar: Denn angenommen PA |- neg(A). Dann auch NN |== neg(A).
  Das ist ein Widerspruch zu NN |== A.

  Rein syntaktisch geht es auch, nur unter der Annahme der Konsistenz, der
  Beweis auf https://en.wikipedia.org/wiki/Rosser%27s_trick ist gut. Habe auch
  geprüft, dass es wieder für HA durchgeht. Dazu benötigt man oben
  angesprochene Verfeinerung (*).

* Was passiert, wenn man in einer intuitionistischen Metatheorie mit
  antiklassischen Axiomen arbeitet? McCarty weiß Antwort:
  https://projecteuclid.org/download/pdf_1/euclid.ndjfl/1093635833

* Löbs Theorem: Genau dann ist Prov(#A) --> A ableitbar, wenn A es ist.

  Die Rückrichtung ist klar.

  Die Hinrichtung geht so: Finde mit dem Diagonallemma eine Aussage B
  mit PA |- (B <-> (Prov(#B) --> A)). Dann kann man einsehen, dass
  PA |- (Prov(#B) --> Prov(#A)). Insgesamt also PA |- B. Somit auch
  PA |- Prov(#B). Und damit PA |- A.

  Siehe
  http://www.michaelbeeson.com/teaching/StanfordLogic/Lecture15Slides.pdf,
  Folie 16. Geht alles auch konstruktiv für HA durch.

  Mit Kontraposition kann man das auch aus Gödels zweitem
  Unvollständigkeitssatz ableiten, aber das geht dann wohl nicht konstruktiv.
  http://web.mit.edu/24.242/www/2ndIncompleteness.pdf, Seite 11.

  Gödel 1 und 2 verallgemeinert "auf A statt bottom":

  Sei B eine Aussage mit PA |- (B <-> (Prov(#B) --> A)).

  Dann sehen wir: (PA |- A  ==>  A)  ===>  B.
  Denn B ist ja äquivalent zu (PA |- B) ==> A. (Hier geht ein, dass die
  Diagonalität nicht nur beweisbar ist, sondern auch stimmt!)
  Gelte also PA |- B. Wir wollen A zeigen. Da PA |- B, auch
  PA |- Prov(#B). Also PA |- A. Nach Voraussetzung somit A.

  Wenn wir das Argument formalisieren, sehen wir:

      PA |- (Prov(#A) --> A) --> B.

  Falls nun PA |- Prov(#A) --> A, so folgt PA |- B, also PA |- Prov(#B),
  also PA |- A.

* Ein Henkin-Satz behauptet seine eigene Beweisbarkeit:

      PA |- (H <-> Prov(#H)).

  Ein solcher ist nach Löbs Theorem beweisbar.

* http://gdz.sub.uni-goettingen.de/pdfcache/PPN379931524_0022/PPN379931524_0022___LOG_0008.pdf

* Man kann ja eigentliche alle Argumentationen in PA oder meinetwegen ZFC
  formalisieren. Aber es gibt eine große Klasse an wichtigen Ausnahmen:
  Argumente, die das Prinzip "Prov(#A) --> A" verwenden. Solche kann man nicht
  formalisieren, denn (vorausgesetzt PA ist konsistent), so ist das Prinzip
  nicht beweisbar (der Fall A = bottom ist Gödels zweiter
  Unvollständigkeitssatz).

  Sind Spezialfälle beweisbar? Für gewisse Arten von Aussagen? Aber eher nicht,
  oder?

  Die Umkehrung, A --> Prov(#A), ist (denke ich) für manche Aussagen beweisbar:
  Für Sigma-Aussagen (geometrische).

* Sei L vom Diagonallemma geliefert mit

      PA |- (L <-> (forall p. len(p) < f(n) --> neg Proof(p, #L))),

  wobei f eine rasch steigende Funktion ist.

  Dann gilt L, unter Annahme der Konsistenz von PA:

      L ist ja (auch, wenn PA nicht sound ist) äquivalent zu der genannten
      allquantifizierten Aussage. Sei also p eine Zahl mit len(p) < f(n).
      Angenommen, p ist ein Beweis von L. Dann weiß PA das auch, also folgt
      PA |- Proof(p, #L). Da PA |- L, folgt damit PA |- neg Proof(p, #L).
      Das ist ein Widerspruch zur Konsistenz.

  Internalisiert folgt: PA |- (Con(PA) --> L). Der das bezeugende Beweis ist
  kurz! (Er enthält n, und vielleicht die Beschreibung von f, aber er ist auf
  jeden Fall kürzer als f(n).)

* Warnung vor "die Axiome sind offensichtlich wahr": Hat man beim naiven
  Mengenkomprehensionsaxiom auch gedacht.

* Logical Dreams: https://arxiv.org/pdf/math/0211398.pdf


=== Parikh

* Es gibt Aussagen, die nur einen langen Beweis haben, aber einen kurzen Beweis,
  dass sie einen Beweis haben.

  Nämlich "Diese Aussage besitzt keinen Beweis von weniger als n Zeichen",
  wobei n eine natürliche Zahl ist, die wir so hochschrauben können, wie wir
  möchten.

  Unter der Annahme, dass PA konsistent ist, kann es nicht sein, dass diese
  Aussage einen Beweis von weniger als n Zeichen besitzt. Denn wenn schon, dann
  beweist PA einen Widerspruch.

  Wir können alle Beweise von weniger als n Zeichen durchgehen. Dabei werden
  wir unter der Konsistenzannahme keinen Beweis der Aussage finden. Diese
  Überlegung kann PA auch beweisen. Damit hat sie die Beweisbarkeit der Aussage
  bewiesen.

  Siehe etwa http://www.math.ucla.edu/~asl/bsl/0903/0903-004.ps,
  Yanofsky: A Universal Approach to Self-Referential Paradoxes,
  Incompleteness and Fixed Points.

  Originalartikel: https://www.jstor.org/stable/pdf/2269958.pdf.


=== Inkonsistenz von PA

* https://www.math.ias.edu/vladimir/sites/math.ias.edu.vladimir/files/2010_09_25_slides.pdf

  Problem mit üblichem "Beweis", dass PA konsistent ist: Nicht alle Teilmengen,
  die über Formeln in PA definiert werden, haben eine "Bedeutung": Für manche
  gilt für keine Zahl, dass beweisbar ist, dass sie in der Menge liegt, oder
  dass beweisbar ist, dass sie nicht in der Menge liegt.


=== Finitistisch akzeptables Schließen

... wird laut manchen Leuten formalisiert durch PRA (primitiv-rekursive
Arithmetik). Manchmal genügt sogar ERA, das ist wie Peano-Arithmetik, aber mit
dem Induktionsprinzip eingeschränkt auf elementar berechenbare Prädikate.

http://www.icm2006.org/proceedings/Vol_II/contents/ICM_Vol_2_03.pdf


=== Wahrheit vs. Beweisbarkeit

* "Because it’s the case that if a number-theoretic statement is true, then its
  witnessing functions exist, we might hope that it would be the case that if a
  number-theoretic statement is provable, then its witnessing functions are
  computable, that is, that we could extract a computer program for the
  witnessing functions from the proof."
  https://xorshammer.com/2008/08/13/kreisels-no-counterexample-interpretation/

  Aber so naiv stimmt es natürlich nicht: Die Aussage "für alle n gibt es ein m
  sodass die n-te Turingmaschine nach m Schritten hält oder niemals hält" ist
  beweisbar in Peano-Arithmetik, aber besitzt keinen berechenbaren Zeugen.


=== Quantorenelimination

* Quantorenelimination ist bei der Theorie algebraisch abgeschlossener Körper
  möglich. Idee: Ersetze zwei Gleichungen

      f(x) = 0  und  g(x) = 0

  mit f(x) = a x^n + ..., g(x) = b x^m + ..., n >= m, durch

      (b  = 0 und (f(x) = 0 und g(x)-bx^m = 0)) oder
      (b != 0 und (b*f(x) - a*x^{n-m}*g(x) = 0 und g(x) = 0)).

  Die neu auftretenden Gleichungen haben geringeren Grad. Schlussendlich
  bleiben nur Gleichungen zwischen Konstanten übrig (die Variable x wurde also
  eliminiert) und Gleichungssysteme bestehend aus einer einzelnen Gleichung
  übrig (welche wegen der Voraussetzung der algebraischen Abgeschlossenheit
  stets lösbar sind). Dann kann man rekursiv mit den in den Konstanten
  versteckten weiteren Variablen weitermachen.

* Quantorenelimination zieht nach sich: Bilder quantorfrei definierter Mengen
  unter definierbaren Abbildungen sind wieder quantorfrei definierbar.

* Auch die Theorie reell abgeschlossener Körper besitzt Quantorenelimination.
  Daher sind Bilder semialgebraischer Mengen unter polynomiellen Abbildungen
  wieder semialgebraisch.

* Inwieweit ist Chevalleys Theorem eine Verallgemeinerung?

* Ting Zhang. A survey of quantifier elimination: syntactic and semantic
  approaches. http://theory.stanford.edu/~tingz/talks/qe.ps

* http://homepages.math.uic.edu/~marker/orsay/orsay2.pdf

* Quantifier elimination in C*-algebras. http://arxiv.org/abs/1502.00573

* Zahlentheoretische Aussagen, die nur die Quantoren "für fast alle n"
  und "es gibt unendlich viele n" verwenden, sind entscheidbar.
  Weil man auch R statt N verwenden kann.
  https://xorshammer.com/2008/08/25/almost-a-number-theoretic-miracle/


=== Analytische Hierarchie

Achtung, hier klassische Logik benutzt!

* Jede Pi_1^1-Aussage ist äquivalent zu einer Aussage der Form

      forall f : N --> N. exists m : N. R(n, f^(m)).

  Dabei ist f^ die "course of values"-Funktion, also f^(n) = (f(0),...,f(n-1)).

  Siehe: Cor. IV.2.10 in /Classical Recursion Theory/ von Odifreddi.

  (Wenn man Mengenquantoren statt Funktionsquantoren verwendet, muss man zwei
  Zahlquantoren verwenden. Stimmt das?)

* Eine Menge X natürlicher Zahlen ist genau dann eine Pi_1^1-Menge,
  wenn es eine rekursive Folge (T_n)_n rekursiver Bäume mit

      n in A  <==>  T_n ist fundiert

  gibt.

  Die Richtung "<==" ist klar, denn die Bedingung, dass T_n fundiert ist, ist
  eine Pi_1^1-Bedingung.

  Zur Richtung "==>" nutzen wir aus, dass die Menge X von der Form
  X = { n | forall f. exists m. R(n, f^(m)) } ist und definieren den Baum T_n
  so: Eine Folge xs von natürlichen Zahlen soll genau dann zum Baum gehören,
  wenn für jede echte Teilfolge ys von xs die Aussage R(n, ys) falsch ist.

  Die Blätter des Baums geben also Plätze an, bei denen R(n, __) das erste Mal
  gilt.

* Eine analoge Aussage gibt es mit fundierten Ordnungen statt fundierten
  Bäumen.

* Mehr steht zur arithmetischen und analytischen Hierarchie in:

  * Beklemishev: Provability, Computability and Reflection
  * Grzegorczyk: An Outline of Mathematical Logic: Fundamental Results and
    Notions Explained

* https://xorshammer.com/2016/05/14/the-arithmetic-hierarchy-meets-the-real-world/


=== Temporale Logik

* Diodoreanische Modalität in Minkowski-Raumzeit (in Goldblatts Buch)


=== Induktive Logik

https://books.google.it/books?id=oxxaRUjhD_QC&printsec=frontcover#v=onepage&q&f=false
Handbook of the History of Logic: Inductive logic
herausgegeben von Dov M. Gabbay, John Hayden


=== Prädikative Zahlentheorie

* https://web.math.princeton.edu/~nelson/books/pa.pdf

* https://www.math.ucsd.edu/~sbuss/ResearchWeb/nelson/talk.pdf


=== Russel konstruktiv statt imprädikativ

http://staff.math.su.se/palmgren/CERRTT.pdf


=== Funktionssymbole

Folgende zwei Theorien zeigen dieselben Formeln, die in der Sprache von HA
formuliert werden können:

1. HA

2. HA ergänzt um je ein Funktionssymbol für jeden Aufbau einer
primitiv-rekursiven Funktion, ergänzt um Axiome für das Funktionssymbol, welche
sich aus dem Aufbau der primitiv-rekursiven Funktion ergeben.

3. HA ergänzt um je ein Funktionssymbol für jede primitiv-rekursive Funktion,
ergänzt um Axiome für das Funktionssymbol, welche sich aus allen möglichen
Aufbauten der primitiv-rekursiven Funktion ergeben. Hier geht ein Lemma ein,
nämlich dass HA die Äquivalenz von Funktionen darstellenden Formeln zeigen
kann, sofern die Funktionen gleich sind.


=== Nächste Schritte

* Kann man explizit x, y mit phi(x) != phi(y) angeben?

* http://golem.ph.utexas.edu/category/2012/12/universe_polymorphism_and_typi.html

* https://arxiv.org/pdf/1504.03380.pdf
