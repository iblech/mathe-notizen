=== Monaden

* Eine Monade in Span(Set) ist nichts anderes als eine kleine Kategorie.
  http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html?showComment=1312587319525#c2392343608124186667

  Genauer: Die Kategorie der internen Kategorien mit Objektobjekt C_0 einer
  Kategorie A ist dasselbe wie die Kategorie der Monoidobjekte in der Kategorie
  Hom_Span(A)(C_0, C_0), also dasselbe wie eine Monade in Span(A).


=== Ind-Kategorie

* Ind-C :=

      Objekte: Diagramme I --> C, I filtriert

      Morphismen: Hom(F, G) := lim_i colim_j Hom(F(i), G(j)).

  = volle Unterkategorie von [C^op, Set] der filtrierten Kolimiten von
    darstellbaren Funktoren

  = ... der flachen Funktoren

  = ... der endlich kostetigen Prägarben  (diese Äquivalenz nur, falls C
  endlich kovollständig).

* C --> Ind-C ist volltreu, rechtsexakt und die Bilder sind kompakte Objekte.

* Beispiel: Ind-Mod(A)^fp = Mod(A).

* Ind-A ist stets eine Grothendieck-Kategorie, wenn A abelsch ist.

Quelle für das alles: nLab.


=== 2 aus 3, Monomorphismen, und so weiter

* f . g Iso, f Mono ==> g Iso (und f Iso)

  Das Inverse für g ist (f . g)^(-1) . f.

  Probe:
  - g^(-1) g = id
  - f . g g^(-1) = f g (f g)^(-1) f = f = f . id.

* f . g Iso, g Epi ==> f Iso (und g Iso)

  Das Inverse für f ist g . (f . g)^(-1).

  Probe:
  - f f^(-1) = id.
  - f^(-1) f . g = g (f g)^(-1) f g = g = id . g.

* Verwandt: Ein Morphismus f : X --> Y ist genau dann ein Iso,
  wenn f_* : Hom(T,X) --> Hom(T,Y) für alle T ein Iso ist (und tatsächlich
  genügt T = Y, um das Inverse g als Urbild von id_Y zu erhalten, und T = X,
  um auch g . f = id_X nachzuweisen).

  Genauer: f ist genau dann ein Iso, wenn Hom(Y,X) --> Hom(Y,Y) surjektiv und
  Hom(X,X) --> Hom(X,Y) injektiv ist.

* Bekannt: X --> Y ist genau dann ein Monomorphismus, wenn

      X ---> X
      |      |
      |      |
      v      v
      X ---> Y

  ein Pullbackdiagramm ist.

* Daraus folgt: Ist X --> Y ein Mono, so (existiert X x_Y X) und X --> X x_Y X
  ist ein Epi (da sogar Iso).

  Umgekehrt existiere X x_Y X und Delta : X --> X x_Y X sei ein Epi.
  Seien außerdem Epis stabil unter Basiswechsel und existieren alle
  Differenzkerne. Dann ist f : X --> Y ein Mono. Sind nämlich a, b : Z --> X
  mit f . a = f . b gegeben, so erhalte Z --> X x_Y X und das
  Faserproduktdiagramm

      Eq(a,b) ---> Z
        |          |
        |          |
        v          v
        X -----> X x_Y X.

  Da X --> X x_Y X ein Epi ist, ist nach Voraussetzung auch Eq(a,b) --> Z
  ein Epi. Also ist a = b.


=== Reguläre Epimorphismen

Angeblich sind reguläre Epis in der Kategorie der Ringe genau die surjektiven
Abbildungen. Sagt Brandenburg.


=== Kanten vs. Pfade

The morphisms in a category are not so much like the edges in a graph as like
the paths in a graph. Edges do not compose, but paths do. Edges are all alike,
but paths are not. In particular, some paths are special in a way that
identifies them as identity morphisms: the paths of length zero. In particular,
an identity morphism is not a loop (and edge from a vertex to itself, which a
path of length 1, not 0.) So in identifying the identity morphisms, we do not
pick out one loop from all of the loops at a given vertex, label it the
identity, and then demand that this labelling be preserved. Instead, we demand
that a path of length 0 be mapped to a path of length 0, which is very
different.

Toby Bartels in:
http://nforum.mathforge.org/discussion/6234/why-do-functors-preserve-identity-/?Focus=49712#Comment_49712


=== Ideale

Ideale von Ringen sind dasselbe wie interne Gruppoide in der Kategorie der
Ringe. http://mathoverflow.net/a/60424/31233


=== Diskrete Kategorien

Eine Kategorie ist genau dann äquivalent zu einer diskreten Kategorie,
wenn sie dünn ist und die Relation "Hom(X,Y) ist bewohnt" eine
Äquivalenzrelation ist, d.h. wenn sie ein dünner Gruppoid ist.

Kategorien, die zu diskreten Kategorien äquivalent sind, und
Äquivalenzrelationen sind also dasselbe.


=== Duale Kategorie

Set^op ist nicht äquivalent zu Set. Denn in Set ist jeder Morphismus ins
initiale Objekt ein Isomorphismus, in Set^op aber nicht.

Siehe auch:
* http://mathoverflow.net/questions/29442/what-is-the-opposite-category-of-the-category-of-modules-or-hopf-algebra-represe/39975#39975


=== Rechenregel adjungierte Funktoren

Sei F -| G. Sei der Isomorphismus

    Hom(FA, B) --> Hom(A, GB)

mit ( )^T und sein Inverses mit T^( ) bezeichnet. Dann gilt

    Gg . omega^T . f = (g . omega . Ff)^T

für omega : FA --> B und

    g . T^mu . Ff = T^(Gg . mu . f)

für mu : A --> GB.

Siehe auch: http://mathoverflow.net/questions/6551/what-is-an-intuitive-view-of-adjoints-version-1-category-theory/6558#6558
All of these examples are particularly nice in the sense that we get triangles
or short exact sequences describing the object we start with in terms of our
complementary approximations (by complementary I mean that there is
orthogonality floating around in all of these examples so we have in some sense
decomposed our category).


=== Bewahrung von Monos/Epis bei adjungierter Transponierung

Sei die Notation wie im vorherigen Abschnitt. Dann gilt:

    f^T = Gf . id_FX^T.
    T^g = T^id_FX . Fg

Daraus kann man ablesen:

* Gf Mono, id_FX^T Mono ==> f^T Mono.
* f^T Mono ==> id_FX^T Mono.

* Gf Epi, id_FX^T Epi ==> f^T Epi.
* f^T Epi ==> Gf Epi.

Ferner gilt:

* f Mono, F treu ==> f^T Mono

* f Iso und eta = id_FX^T Iso ==> f^T Iso;
  wenn (f Iso ==> f^T Iso) für alle f zwischen allen Objekten gilt,
  so ist umgekehrt eta ein natürlicher Iso.


=== Noch etwas

* Sei f : A --> GX. Dann habe T^f : FA --> X.
  Habe id : FA --> FA, also auch id^T : A --> GFA.

  Dann gilt:

      G(T^f) . id^T = (T^f . id)^T = (T^f)^T = f.

* Sei weiterhin F -| G. Dann ist G genau dann volltreu, wenn
  FG --> Id ein Iso ist. F ist genau dann volltreu, wenn Id --> GF ein Iso ist.

  Das sagt Huybrechts, F-M, Seite 8.

  Beispiel: Abelianisierung -| Vergiss; Vergiss ist volltreu, und in der Tat
  ist Abelianisierung(A) --> A ein Iso für abelsche Gruppen A.

* Sei F -| G. Dann auch F_* -| G_* auf den Funktorkategorien.

  Der Iso Hom_[C,E](L . F, G) --> Hom_[C,D](F, R . G) schickt dabei
  eine natürliche Transformation eta auf

      (Reta_X . id_LFX^T)_X.

  Die Umkehrung schickt mu auf (^Tid_GX . Lmu_X)_X.

* Dreiecksidentitäten für eps : LR ==> Id und eta : Id ==> RL:

      eps_LX . L eta_X = id_LX

      R eps_Y . eta_RY = id_RY

* eps heißt auch Koeins, eta heißt Eins.


=== Isomorphismen unter Bijektionen von Hom-Mengen

* Der Funktor "Aufrundung" : Q --> Z ist doch linksadjungiert zum
  Funktor "als rationale Zahl ansehen" : Z --> Q.

  Also gibt es für alle rationalen Zahlen q und alle ganzen Zahlen z
  natürliche Isomorphismen

      Hom_Z(Aufrundung(q), z) ~~ Hom_Q(q, z).

  Sei nun speziell q = 2,7 und z = 3. Dann enthält die linke Seite genau
  ein Element; dieses ist ein Isomorphismus. Die rechte Seite dagegen
  enthält keinerlei Isomorphismen.

* Für R-Moduln (R kommutativ) hat man doch die "Currying-Adjunktion"

      Hom(M, Hom(N,T)) ~~ Hom(M tensor N, T).

  Sei speziell M = R, N = R^7 und T = R^7. Dann enthält die rechte Seite
  einen Isomorphismus, nämlich R tensor R^7 --> R^7, r tensor v |-> rv.
  Die linke hingegen nicht, denn M = R ist nicht isomorph zu Hom(N,T) ~~
  R^49 (außer R = 0).


=== Upgrade von Quasiäquivalenzen zu adjungierten Äquivalenzen

Sei L : C --> D mit Quasiinversem R : D --> C, vermöge Isomorphismen

    eps : LR ==> Id  und  eta : Id ==> RL.

Dann können wir eps durch eine natürliche Transformation ersetzen, sodass
(L,R,eps',eta) ein adjungiertes Paar wird.

Lemma: LR eps_Z = eps_LRZ, RL eta_Q = eta_RLQ.
Verwende dazu einfach die Natürlichkeitsdiagramme von eps bzw. eta, angewendet
auf eps_Z bzw. eta_Q und kürze sich ergebende Isomorphismen.

Lemma: LR eps_LX . L eta_RLX = L eta_X . eps_LX.
Wende dazu R auf diese Gleichung an (R treu), dann steht genau das
Natürlichkeitsdiagramm für eta bzgl. R eps_LX dran. (Verwende dazu auch das
vorherige Lemma.)

Lemma: R eps_LRY . RL eta_RY = eta_RY . R eps_Y.
Das ist das Duale von dem vorherigen Lemma.

Setze dann

    eps'_Y := eps_Y . L eta_RY^(-1) . eps_LRY^(-1).

Dann erfüllt (eps',eta) die Dreiecksidentitäten:

* eps'_LX . L eta_X =
  eps_LX . L eta_RLX^(-1) . eps_LRLX^(-1) . L eta_X =
  eps_LX . (eps_LRLX . L eta_RLX)^(-1) . L eta_X =
  eps_LX . (L eta_X . eps_LX)^(-1) . L eta_X =
  eps_LX . eps_LX^(-1) . L eta_X^(-1) . L eta_X =
  id.

* R eps'_Y . eta_RY =
  R eps_Y . RL eta_RY^(-1) . R eps_LRY^(-1) . eta_RY =
  R eps_Y . (R eps_LRY . RL eta_RY)^(-1) . eta_RY =
  R eps_Y . (eta_RY . R eps_Y)^(-1) . eta_RY =
  id.

* Außerdem ist eps' immer noch komponentenweise ein Iso.

* Und ganz sicher ist eps' natürlich, als Verkettung natürlicher Trafos:

      eps' = eps . (L eta R)^(-1) . (eps LR)^(-1)

Wie kommt man darauf? Die Dreiecksidentität gibt

    eps'_LX . L eta_X = id

vor. Daher muss eps'_LX = L eta_X^(-1) sein. Mit diesem Hintergrund kommt man
auf die Definition von eps'_Y für Y nicht unbedingt von der Form LX.


=== Eindeutigkeit von adjungierten Quasiinversen

Sei F -| G und F -| G', wobei die Eins und Koeins jeweils Isomorphismen sind.
Dann gibt es genau einen Iso psi : G ==> G' mit

    eps' . F psi = eps und
    psi F . eta = eta'.

Tatsächlich sind die beiden Bedingungen wegen der Dreiecksidentitäten
äquivalent (die sagen ja eta_FX = F eps_X^(-1); nimm die erste Gleichung;
schalte F vor; verwende die Identität; kürze F von links; stelle um; dann steht
die zweite Gleichung dran).


=== Kofinalität

Def.: Ein Funktor H : D_0 --> D heißt genau dann kofinal, wenn gilt:
1) Für alle d \in D existiert ein d_0 \in D_0 und ein Morphismus
       d --> H d_0
   in D.
2) Für jedes d \in D und Morphismen
       d -----> H d_0
       |
       v
     H d_0'
   existieren d_0 --> d_1, d_0' --> d_1, deren Bilder unter H dieses Diagramm zu
   einem kommuativen erweitern.

Prop.: Kokegel(F) ~~ Kokegel(F . H) für F : D --> C, d.h. die Kokegelkategorien
sind sogar isomorph.


=== Dichtheit

Eine volle Unterkategorie D von C ist genau dann dicht, wenn die eingeschränkte
Yoneda-Einbettung

    C --> Set^(D^op)

noch volltreu ist.

"==>" Habe noch das Yoneda-Lemma Hom_(Set^(D^op))(Hom(__,X),F) ~~ F(X)
      für Prägarben F, die Kolimiten auf Limiten schicken.

"<==" Wenn zum Nachweis der universellen Eigenschaft ein beliebiger Kokegel
      gegeben ist, kann man daraus eine natürliche Trafo zwischen den
      zugehörigen darstellbaren Prägarben basteln. Die Tatsache, dass es genau
      ein Urbild dieser natürlichen Trafo gibt, zeigt die Behauptung.

In Vect(R) liegt übrigens { R } nicht dicht: Sei V ein Vektorraum. Dann sieht
die relevante Indexkategorie wie folgt aus:

            0
      +-----^-----+
      |     |     |          (genau einen Morphismus 0 --> v
      |     |     |          für v aus U \ {0})
      v     v     v          
    ###    ###   ###   ...   (für jeden eindimensionalen Unterraum U
                             eine Ansammlung von Gruppoiden:
                             für jeden Vektor v aus U \ {0} jeweils ein Objekt
                             und je einen Morphismus zwischen zwei solchen
                             Objekten)

Der Kolimes ist daher dasselbe wie das Koprodukt über alle eindimensionalen
Unterräume.


=== Limiten von Limiten

Sei F : I x J --> C ein Diagramm.
Besitze C folgende Limiten: L_i := lim F(i, __).
Daraus kann man ein Diagramm L : I --> C basteln.
Besitze C einen Limes dieses Diagramms: K := lim L_i.
Dann wird K zu einem Limes von F.


=== Allgemeine vs. filtrierte Kolimiten

Ein Koprodukt unendlich vieler Summanden ist filtrierter Kolimes des
gerichteten Systems der Koprodukte von je endlich vielen Summanden.
Sagt Todd Trimble.


=== Idempotente

Def.:
1) Ein Morphismus e : X --> X heißt genau dann idempotent, wenn e . e = e.
2) Eine Zerfällung eines Idempotenten e besteht aus Morphismen
       p : X --> Y, i : Y --> X
   mit i p = e, p i = id.

Prop.: In einer Ab-angereichterten Kategorie sind äquivalent:
(1) Alle Idempotenten haben einen Kern.
(2) Alle Idempotenten zerfallen.

Bew.:
* (1) ==> (2): Sei e^2 = e. Finde Kern K -i-> A von 1-e.
  Finde dann Morphismus A-p->K mit i p = e. Existiert und ist eindeutig, da
  A -e-> A Möchtegern-Kern von 1-e. Es folgt p i = id, denn da i ein Mono ist,
  genügt es i p i = e i = i nachzuweisen, und das stimmt, da (1 - e) i = 0.
* (2) ==> (1): Sei e^2 = e. Finde Zerfällung von 1-e: 1-e = i p, id = p i.
  Dann ist Y -i-> X -e-> X ein Kerndiagramm, denn e i = (1 - ip) i = i - ipi = 0
  und für jedes Z -j-> X mit e j = 0 ist pj : Z --> Y eindeutiger Morphismus
  mit i pj = j.

Prop.: Die Angabe einer Zerfällung eines idempotenten Morphismus e : X --> X
ist gleichbedeutend mit der Angabe eines Differenzkerns (oder eines
Kodifferenzkerns) von (e, id).

Prop.: In erreichbaren Kategorien zerfallen alle Idempotenten.
Bew.: Sei e : A --> A mit e^2 = e. Dann ist A mit den Morphismen id und e
ein filtriertes Diagramm und besitzt daher einen Kolimes p : A --> B.
Da auch e : A --> A ein Kokegel ist, gibt es einen eindeutigen Morphismus
i : B --> A mit i p = e. Daraus folgt p i p = p. Da p : A --> B Kolimes
ist, kann es nur einen Morphismus psi mit psi p = p geben. Da id das tut,
muss p i = id sein.

Es gilt auch die Umkehrung! Jede kleine Kategorie, in der alle Idempotenten
zerfallen, ist erreichbar, siehe Adámek, Rosicky, Prop. 2.6.

Prop.: Wenn in einer Kategorie C alle Idempotenten zerfallen, so sind Retrakte
darstellbarer Prägarben auf C schon selbst darstellbar.

Bew.: Sei F ein Retrakt von X^. Dann erhalte einen idempotenten
Morphismus e : X^ --> X^. Dieser kommt von einem idempotenten
Morphismus f : X --> X und zerfällt nach Voraussetzung (über ein Objekt Y). Da
die Yoneda-Einbettung Limiten bewahrt, muss daher F isomorph zu Y^ sein.


=== Eingeschränktes Yoneda-Lemma (eine völlige Tautologie!)

Sei D eine volle Unterkategorie von C. Dann hat man

    Hom_(Set^(D^op))(Hom(__, X), F) ~~ lim_{d --> X} F(d)

für X in C, F in Set^(D^op).


=== Yoneda angereichert in der Kategorie V der Wahrheitswerte

Sei P eine Quasiordnung aufgefasst als angereicherte Kategorie.

Eine Prägarbe auf P ist dann durch die Angabe einer nach unten abgeschlossenen
Teilmenge von P gegeben. Eine solche ist eine Bastelanleitung für ein Supremum
(Kolimes).

Die Aussage, dass eine Prägarbe Kolimiten aus P auf Limiten in V schickt,
sollte gleichbedeutend damit sein, dass die zur Prägarbe gehörige Teilmenge
"stabil unter Suprema" ist: Immer wenn ein System (Diagramm) in P ein Supremum
besitzt, muss die Zugehörigkeit des Supremums gleichbedeutend sein mit der
Zugehörigkeit aller Elemente des Diagramms.

Nächste Schritte:
* Stimmt das "sollte gleichbedeutend" sein?


=== Yoneda-Lemma als Aussage über Termmodelle

You can think of "category" as meaning the same thing as "algebraic theory in a
multisorted language with only unary functions" (the objects of the category
being the sorts of the language, the morphisms being the definable functions,
and the equalities between (composites of) morphisms being the laws of the
theory). From this perspective, a functor from C to Set is simply a model of
the theory corresponding to C, and natural transformations of such functors are
homomorphisms of models. The Yoneda lemma then is about free models:
specifically, it says that for every sort s, the "term model" of terms with a
single variable, of sort s (equivalently, definable functions with domain s) is
the free model on a single generator of sort s. [It may be unfamiliar when
expressed as "Nat(Hom(s, -), M) ~= M(s), naturally in M", but that is indeed
all this categorical expression is saying]

Quelle: Sridhar Ramesh in
http://mathoverflow.net/questions/3184/philosophical-meaning-of-the-yoneda-lemma/15143#15143


=== Inneres Hom in Scheibenkategorien

* In Set/A ist das innere Hom gegeben durch:

    HOM(X, Y) = { <a, X|_a --> Y|_a> }.

* In G-Set/A ist das innere Hom gegebe durch dieselbe Konstruktion,
  mit G-Wirkung durch

      g . <a,f> := <ga, gf>,

  wobei (gf)(x) = g . f(g^(-1) . x).


=== Limiten und Kolimiten in der 1-Kategorie Cat

Cat ist vollständig und kovollständig.


=== Beispiele für kodarstellbare Funktoren

* Set --> Set, X |--> {*} wird durch die leere Menge dargestellt.

* Set --> Set, X |-> Hom(A,X) x Hom(B,X) wird durch das Koprodukt und das
  Tupel (inj_A, inj_B) dargestellt.

* Vect --> Set, X |--> {*} wird durch R^0 dargestellt.

* Vect --> Set, X |--> X wird durch R^1 und 1 \in R^1 dargestellt.

* Quot, Tensorprodukt, äußere Algebra, Faktormodul, freier Modul,
  Z[X], kontravarianter Potenzmengenfunktor


=== Zusätzliche Struktur

Wie kann man sicher sein, dass ein Funktor F : C --> D sich nicht upgraden
lässt zu einem Funktor C --> D', wobei D' eine Kategorie strukturierter Objekte
von C ist?

http://qchu.wordpress.com/2013/09/08/the-homotopy-groups-are-only-groups/#more-13969

Hängt mit Lawvere-Theorien zusammen.


=== Reflektive Unterkategorien

Eine volle Unterkategorie i : D --> C heißt genau dann reflektiv, wenn die
Inklusion einen Linksadjungierten besitzt, den sog. Reflektor.

* Die Unterkategorie D wird dann monadisch über C, d.h. D ist die Kategorie
  der Algebren der Monade ir : C --> C.

* ri = id : D --> D.

* D ist abgeschlossen unter Limiten, die in C existieren.
  (Denn die Inklusion ist monadisch.)

* Kolimiten werden in D so gebildet: Den Kolimes in C bilden und dann den
  Reflektor anwenden. Denn:

      Hom_D(r(colim X_i), T) = Hom_C(colim X_i, T)
        = lim Hom_C(X_i, T) = lim Hom_D(r(X_i), T)
        = lim Hom_D(X_i, T).  (ri = id.)

* Ein Morphismus in D ist ein Mono in D genau dann, wenn er ein Mono in C ist.


=== Lokalisierung

* Motivation:
  http://mathoverflow.net/questions/173546/why-localize-spaces-with-respect-to-homology

* Historische Quelle (zu sichten):
  http://arxiv.org/pdf/1012.5020v3.pdf


=== Grafische Notation

* http://arxiv.org/abs/1401.7220
  Category Theory Using String Diagrams
  Daniel Marsden


=== Mannigfaltigkeiten als Kategorien

* http://mathoverflow.net/questions/31732/folk-functorial-figuring
  verstehen


=== Nichtäquivalente Kategorien

* Coh(X), für eine vollständige Varietät über einem algebraisch abgeschlossenen
  Körper, ist immer eine Krull--Schmidt-Kategorie.
  http://en.wikipedia.org/wiki/Krull%E2%80%93Schmidt_category

  Coh(k[X]) ist es dagegen nicht: Das Objekt k[X] ist darin irreduzibel, sein
  Endomorphismenring ist aber nicht lokal. Die Irreduzibilität kann man so
  sehen: Sei k[X] = A oplus B. Tensorieren mit k(X) zeigt, dass einer der
  beiden Faktoren nach Tensorieren Null sein muss (betrachte Dimensionen als
  k(X)-Vektorräume). Also ist A oder B ein Torsionsmodul. Aber k[X] ist
  torsionsfrei. Also ist A oder B Null.


=== Kopotenzen

* Die Kopotenz X * A, X Menge, A Objekt einer Kategorie C, ist
  das kodarstellende Objekt für den Funktor Set(X, C(A, __)).
  Es gilt also:

      C(X * A, B) ~~ Set(X, C(A, B)), natürlich in B.

  Idee: X * A = coprod_{x in X} A.

* Schreibt man den Isomorphismus von links nach rechts als

      phi |-> (x |-> phi_x),

  so bedeutet die Natürlichkeit in B, dass

      (f . phi)_x = f . phi_x für alle x aus X.

* Wenn für alle Objekte A die Kopotenz X * A existiert,
  erhält man für g : A' --> A auch induzierte Morphismen X*g : X*A' --> X*A.
  Diese erfüllen

      phi_x . g = (phi . (X*g))_x.

* Die Potenz A^X stellt man sich als prod_{x in X} A vor.


=== Enden und Koenden

* Ein Ende eines Funktors C^op x C --> D ist ein terminaler Keil.
  Ein Koende ist ein initialer Kokeil.

* int_c S(c,c) = lim [
      S(b,b)
            \
             v
              S(b,c)
             ^
            /
      S(c,c)
  ] = eq [ prod_c S(c,c) ===> prod_{f:b->c} S(b,c) ].

* Jeder Limes ist auch ein Ende: lim F = int_i F(i).
  Der Integrand ist also der halbkonstante Funktor

      I^op x I --> C, (i,j) |-> F(j).

* Sei S : C^op x C --> Set. Dann ist int_c S = Menge der S-Keile mit Spitze 1.

* Das australische Ninja-Yoneda-Lemma für Funktoren K : C^op --> Set:

      K = int^c Kc x Hom_C(__,c)

  Der Nachweis gelingt elementar oder mit dem Ansatz Hom(Kx,y) = ...
  Der initiale Kokeil besteht aus den natürlichen Transformationen

      Kc x Hom_C(__,c) --> K, auf b: (s,phi) |-> K(phi)(s).

* Nat(L, S) = int_c A(Lc, Sc) für Funktoren L, S : C --> A.

* Sei E eine Garbe auf X. Dann Gamma(X, E) = Hom(1, E) = int_U Hom(1(U), E(U)) =
  int_U E(U). Allerdings ist das nicht unendlich cool, da diese Ende also
  einfach ein Limes ist, und die Indexkategorie ein initiales Objekt besitzt.

* Kann tropische Integrale, insbesondere Suprema, als Enden ansehen.
  http://mathoverflow.net/a/80719/31233

* Fosco Loregian.
  This is the (co)end, my only (co)friend.
  http://arxiv.org/abs/1501.02503


=== Tensorprodukte von Funktoren

* Sei R ein Ring. Sei A ein Rechts-R-Modul, d.h. ein Ab-Funktor R^op --> Ab.
  Sei B ein Links-R-Modul, d.h. ein Ab-Funktor R --> Ab. Dann ist

      A tensor_R B = int^R A tensor_Z B.

  (Ohne die Ab-Bedingung reden wir nur über abelsche Gruppen mit Wirkung des
  multiplikativen Monoids von e.)

* Der von einer Menge X frei erzeugte R-Modul ist das Koende

      int^n X^n * R^n.

* Sei X : J --> D und W : J^op --> Set. Dann ist das Tensorprodukt
  das Objekt

      W star_J X = int^j W(j) * X(j)

  in D. Also:

      Hom(W star_J X, d) = int_j Hom(W(j) * X(j), d) =
          int_j Hom(W(j), Hom(X(j), d)) =
          Nat(W, Hom(X(__), d)).

  Das Tensorprodukt W star_J X heißt auch Kolimes von X mit Gewicht W.

  An der Formel erkennt man auch die übliche Tensor/Hom-Adjunktion, nur
  aufgepimpt!

      __ star X -| Hom(X(__), __)

  als Adjunktion zwischen Funktoren auf [J^op, Set] und J.

  Korollar: W star X ist kostetig in W.

  Spezialfall: W = konstant 1. Dann ist W star_j X = colim X.

* Ko- und kontravariante Hom-Funktoren sind wie freie Moduln:

      D(__, d) tensor_D F = Fd
      G tensor_D D(d, __) = Gd

  D(__, d) verhält sich also wie eine bei d konzentrierte Delta-Distribution!

* (Lan_K F)(d) = D(K(__), d) tensor_C F.  (punktweise Kan-Erweiterung)

* |X| = X_* tensor_Delta Delta^*  (geometrische Realisierung).

http://www.math.harvard.edu/~eriehl/cathtpy.pdf, Seite 46.


=== Gewichtete Limiten und Kolimiten

* colim_W F = int^c W(c) * F(c).
  Hier muss W kontravariant sein.

  Dabei Hom(X*A, T) = Hom(X, Hom(T,A)).

  Also Hom(colim_W F, T) = Nat(W, Hom(F(__), T)).

* lim_W F = int_c F(c)^W(c).
  Hier muss W kovariant sein.

  Dabei Hom(T, A^X) = Hom(X, Hom(T,A)).

  Also Hom(T, lim_W F) = Nat(W, Hom(T, F(__))).

* Seien W, F : C --> Set. Dann lim_W F = int_c Hom(W(c),F(c)) = Nat(W,F).
  Passt auch im Fall W = 1. Dann ist die rechte Seite die Menge der F-Kegel mit
  Spitze 1.

* Gewichtete Limiten und Kolimiten lassen sich im unangereicherten Kontext
  einfach als gewöhnliche Limiten und Kolimiten ausdrücken. In einem
  angereicherten Kontext aber nicht. Sagt http://arxiv.org/pdf/1501.02503v2.pdf
  auf Seite 23.


=== Kan-Erweiterungen

* Lan_p -| p^* -| Ran_p.

* Lokale Definition: Sei p : C --> C' und F : C --> D. Dann ist
  Lan_p(F) ein Funktor C' --> D zusammen mit einer natürlichen Trafo

      eps : F ==> Lan_p(F) . p,

  wobei dieses Datum unter all solchen Daten initial ist: Ist G : C' --> D
  ein Funktor zusammen mit einer Trafo alpha : F ==> G . p, so existiert genau
  eine Trafo psi : Lan_p(F) ==> G mit

      alpha = psi p . eps.

* Eine punktweise Kan-Erweiterung ist eine, die durch die Limes- bzw. Kolimes-
  Formel gegeben wird. Punktweise Erweiterungen sind stets auch globale, aber
  im Allgemeinen nicht umgekehrt.

      (Lan_p(F))(c') = colim[ (p/c') --> C --F--> D ].

  Die Indexkategorie hat als Objekte Morphismen p(c) --> c'
  und als Morphismen kommutative Dreiecke (gegeben durch Morphismen in C).

* Eine Rechts-Kan-Erweiterung ist genau dann punktweise, wenn sie von allen
  kodarstellbaren Funktoren Hom(X, __) bewahrt wird.

* Absolute Kan-Erweiterungen sind stets auch punktweise, aber nicht umgekehrt.

* Sei p : C --> 1. Dann ist Lan_p = colim und Ran_p = lim.

* Lan_p Hom_C(c, __) = Hom_C'(p(c), __).

* Sei Y : Delta --> [Delta^op,Set] die Yoneda-Einbettung und sei
  Delta : Delta --> Top der Simplexfunktor. Dann Lan_Y Delta = |.|.

* Ind_f -| f^*.

* Sei f : X --> Y ein Morphismus von Siten, gegeben durch einen
  Funktor f^t : S_Y --> S_X. Dann habe (f^t)^* : PSh(X) --> PSh(Y),
  den (Achtung!) Pushforward-Funktor. Dessen Linksadjungierter ist per
  Definition der Pullback-Funktor; dieser ist also die Links-Kan-Erweiterung
  längs f^t.

* Sei p volltreu. Sei Lan_p(F) eine punktweise Links-Kan-Erweiterung.
  Dann ist F ==> Lan_p(F) . p ein Iso.

  Denn: Die Indexkategorie für Lan_p(F)(p(c)), nämlich p/p(c), hat dann ein
  terminales Objekt, nämlich p(c) --id--> p(c). Somit ist der Kokegel drüber
  einfach F(c).

  Es genügt schon, dass p "genauso treu wie F" ist: Wenn p(f) = p(g),
  dann F(f) = F(g).

* Sei eps bzw. eta ein Iso. Dann ist p genauso treu wie F.

* Falls p bijektiv auf Objekten ist, gibt es (fast) keinen Unterschied zwischen
  1-kategorieller und 2-kategorieller Eigenschaft. Siehe
  derivierte-kategorien.txt.

* Sei L -| R. Dann L . Lan_p(F) = Lan_p(L . F).

  Für die globalen Erweiterungen beweist das folgende Rechnung:

      Hom(L . Lan_p(F), G) = Hom(Lan_p(F), R . G) =
          Hom(F, R . G . p) = Hom(L . F, G . p).

* Ein Funktor R : C --> D besitzt genau dann einen Linksadjungierten,
  wenn Ran_R(Id_C) existiert und von R bewahrt wird.

  In diesem Fall gilt: Ran_R(Id_C) -| R.

* Ein Funktor K ist genau dann dicht, wenn Id vermöge der kanonischen
  Morphismen eine punktweise Links-Kan-Erweiterung von K längs K ist; etwas
  unpräziser:

      K dicht  <==>  Lan_K(K) = Id.

  Insbesondere gilt für die Yoneda-Einbettung Y : C --> C^:

      F = Lan_Y(Y)(F) für alle Prägarben F.

  Noch mal anders:

      F tensor_C Y = F.

  So ist auch klar, wie man eine Prägarbe als Bastelanleitung für einen Kolimes
  ansehen kann: Hat man C --> H, so definiert F den Kolimes F tensor_C H.

* Ende-Formel:

      (Ran_K T)(c) = int_m (Tm)^C(c,Km)

* Die Koende-Formel liefert (wenn sie denn funktioniert, d.h. wenn die
  fraglichen Koenden existieren) sogar eine punktweise Kan-Erweiterung.
  Genauer:

      int^m C(Km,c) * Tm = colim(Tm --> Tm').

  Dabei ist die Indexkategorie für den Kolimes K/c, d.h. Objekte sind
  Morphismen Km --> c und Morphismen sind Morphismen m --> m' derart,
  dass (Km --> c) = (Km --> Km' --> c).

  Anmerkung: Habe nur bewiesen, dass ein Kokeil für die linke Seite ein Kokegel
  für die rechte ist.

  Man kann aber auch die (schwächere Aussage) nachweisen, dass der über diese
  Formel definiere Funktor L eine globale Kan-Erweiterung ist. Dazu mit
  Nat(L,S) ansetzen, die Ende-Formel für die Menge der natürlichen
  Transformationen verwenden, sukzessive weitermachen, bis schlussendlich die
  Menge Nat(T,SK) dransteht.

* Rechtsadjungierte vertauschen mit Rechts-Kan-Erweiterungen;
  Linksadjungierte vertauschen mit Links-Kan-Erweiterungen.

* Sei Hom(d,__) ein Rechtsadjungierter, d.h. existieren alle Kopotenzen
  X*d. Dann vertauscht Hom(d,__) mit Rechts-Kan-Erweiterungen.

* Eine Rechts-Kan-Erweiterung von T : M --> A längs K : M --> C im Fall
  von Quasiordnungen ist
  - eine monotone Abbildung R : C --> A
  - sodass R(Km) <= Tm für alle m aus M
  sodass für alle R' : C --> A mit R'(Km) <= Tm für alle m aus M gilt,
  dass R'(c) <= Rc für alle c aus C.

  Limesformel:   Rc = inf { Tm | m mit c <= Km }.
  Kolimesformel: Lc = sup { Tm | m mit Km <= c }.

  Zum Beispiel ist die RKE von Abrundung : Q --> Z längs Q --> R
  die Abrundung auf R. (Die LKE auch.)

* In einer 2-Kategorie, in der alle 2-Morphismen invertierbar sind,
  gibt es keine Unterschiede zwischen RKE und LKE: Ist (R,eps) eine RKE,
  so ist (R,eps^(-1)) die zugehörige LKE.

  Es genügt auch schon, dass alle 2-Morphismen zwischen 1-Morphismen M --> A
  invertierbar sind. Das ist zum Beispiel erfüllt, falls wir in der 2-Kategorie
  der Kategorien arbeiten und A ein Gruppoid ist.

  Das wiederum ist insbesondere dann der Fall, wenn wir die ganze Zeit über
  Mengen reden.

* Kan-Erweiterungen bei Topoi: http://home.math.au.dk/kock/postulated.pdf

Quellen:
* Mac Lane, Kapitel 10
* http://www.math.harvard.edu/theses/senior/lehner/lehner.pdf
* Emily Riehl, http://www.math.harvard.edu/~eriehl/cathtpy.pdf


=== Codensity-Monade

* Codensity(G) = Ran_G(G) für G : B --> A.

* Falls punktweise: Codensity(G)(X) = int_{Y:B} (GY)^A(X,GY).

* Speziell für G den Vergissfunktor von Körpern nach Ringen:

      Codensity(G)(R) = product_{p Primideal von R} Quot(R/p).


=== Profunktoren

* Ein Profunktor A -/-> B ist ein Funktor A x B^op --> Set.
  Andere sagen: A^op x B --> Set.

* Die Komposition von F : A -/-> B mit G : B -/-> C ist

      (G . F)(a,c) = int^b G(b,c) x F(a,b).


=== Grafisches Kalkül für Kategorien, Funktoren und natürliche Transformationen

Habe mir mal folgendes überlegt:

* Sei F treu. Dann | ... = | ::: ==> ... = :::, wenn | F bezeichnet.

* Sei F wesentlich surjektiv. Dann ... | = ::: | ==> ... = :::.

Natürlich ist hier die Schreibrichtung ganz entscheidend!


=== Nächste Schritte

* Kurz über "Cat ist vollständig und kovollständig" nachdenken.

* Affine Schemata sind also Algebren über der Monade Sch --> Sch,
  X |-> Spec Gamma(X,O_X). Was hat das zu bedeuten?
