=== Assemblies

* Sei A eine PCA. Eine A-Assembly ist dann eine Menge X zusammen mit je einer
  bewohnten Teilmenge R_x <= A für jedes Element x aus X. Wir schreiben genau
  dann

      a |== x,  wenn  a in R_x.

* Ein Morphismus von Assemblies ist eine Abbildung der zugrundeliegenden
  Mengen für den es einen Realisierer e gibt: ein Element aus A mit der
  Eigenschaft, dass

      für alle x aus X und alle a mit a |== x gilt:
          ea |== f(x).

* Eine Assembly heißt genau dann modest (anständig), wenn:

      e |== x  und  e |== y   ===>   x = y.

  Eine anständige Assembly ist also dasselbe wie eine Menge X zusammen mit
  einer partiellen Surjektion A --> X.

* Die volle Unterkategorie der anständigen Assemblies ist reflektiv.

* Ebenso ist Set eine reflektive volle Unterkategorie. (Dabei nehmen wir
  als Realisierer einfach alle Elemente aus A.)

* Die Kategorie der Assemblies ist kartesisch abgeschlossen und regulär.
  Außerdem besitzt sie (wie auch die Kategorie der anständigen Assemblies)
  endliche Kolimiten. Die Einbettung Mod --> Asm bewahrt diese. Auch Mod ist
  regulär.

  Das Exponential Y^X ist als Menge gegeben durch die Menge der
  Assembly-Morphismen X --> Y. Genau dann schreiben wir e |== f,
  falls e ein Realisierer für f wie in der Definition eines Assembly-Morphismus
  ist.

  Ist Y anständig, so ist es auch Y^X.

* Ein Morphismus in Asm oder Mod ist genau dann ein Mono/Epi, wenn die
  zugrundeliegende Abbildung injektiv/surjektiv ist.

* Ein Morphismus in Asm oder Mod ist genau dann ein regulärer Epi,
  wenn es auch einen Realisierer für die Urbilder gibt, wenn also die interne
  Aussage "die Abbildung ist surjektiv" wahr ist.

* Ein Morphismus f in Asm ist genau dann ein regulärer Mono, wenn
  er ein Mono ist und wenn es einen Realisierer e gibt sodass,
  falls a |== f(x), dann ea |== x.

  Letzteres ist genau dann der Fall, wenn in der internen Sprache Zugehörigkeit
  zum Unterobjekt negneg-stabil ist. (Stimmt die Äquivalenz?)

* Schon in Asm (und Mod?) kann man Logik erster Ordnung interpretieren.
  Details stehen in Streicher.


=== Konstruktion des effektiven Topos

Nach https://webdpmms.maths.cam.ac.uk/~martin/Research/Oldpapers/hyland-effectivetopos.pdf.

* Objekte: Paare (X,=), wobei X eine Menge ist und (=) ein
  "Nichtstandardprädikat" auf X x X ist, also eine Relation r |== (x=y)
  zwischen Zahlen und Elementen von X x X. Dabei muss gelten:

  * Es gibt eine Maschine, die die Symmetrie von (=) bezeugt,
    die also Realisierer von (x=y) in Realisierer von (y=x) umwandelt.

  * Es gibt eine Maschine, die die Transitivität von (=) bezeugt.

  (Reflexivität fordert man nicht. Wir schreiben "Ex" für (x=x).)

  Das ist also nicht ganz dasselbe wie eine Assembly, da wir keinen Begriff von
  Realisierern für die Elemente von X haben.

  Ein solches Paar (X,=) gibt aber Anlass zu einer Assembly. Nämlich die, die
  als Trägermenge X' := { x in X | ex. r |== (x=x) } und als
  Realisierbarkeitsrelation r |== x <==> r |== (x=x) hat. Die Relation (=) gibt
  dann ein Unterobjekt von X' x X': Trägermenge { (x,y) in X' x X' | ex. r |== (x=y) },
  Realisierbarkeitsrelation NICHT "r |== (x,y) <==> r |== (x=y)", sondern
  "r |== (x,y) <==> pi_1(r) |== x und pi_2(r) |== y und pi_3(r) |== (x=y)",
  Inklusion offensichtlich. Aus Realisierbarkeitssicht ist diese Relation dann
  reflexiv, symmetrisch und transitiv.

* Morphismen (X,=) --> (Y,=) sind Äquivalenzklassen funktionaler Relationen G
  (Nichtstandardprädikate auf X x Y):

      |== G(x,y) wedge x = x' wedge y = y' --> G(x',y')
      |== G(x,y) --> Ex wedge Ey
      |== G(x,y) wedge G(x,y') --> y = y'
      |== Ex -> exists y. G(x,y)

  Mit "|==" ist hier etwa gemeint: Es gibt eine Maschine, die Paare (r,s,t) mit
  r in G(x,y), s |== (x=x'), t |== (y=y') nimmt und eine Zahl u mit u in
  G(x',y') ausgibt.

  Zwei solche Relationen G und H sind genau dann äquivalent, wenn

      |== G(x,y) <--> H(x,y).

* Der Unterobjektklassifizierer ist folgendes Objekt: (Sigma,<->),
  wobei Sigma = P(N) und r |== M <-> N genau dann, wenn r eine Maschine ist,
  die Elemente aus M auf Elemente aus N abbildet.

  Hm. Diese Relation ist reflexiv, Sigma ist also wirklich groß (hat viele
  globale Elemente).

* Achtung: Die zugrundeliegende Menge eines Objekts (X,=) ist *keine*
  Isomorphieinvariante. Dagegen ist Γ(X,=) es natürlich schon.

* Ein Objekt (X,=) ist genau dann separiert, wenn es isomorph ist zu
  einem, für das aus Bewohntheit von [[ x = x' ]] schon folgt, dass x = x'.


=== Realisierbarkeitslogik

* r |== neg(phi) bedeutet: Es gibt keinen Realisierer für phi.
  Dabei geht r auf der rechten Seite gar nicht ein!

* r |== neg(neg(phi)) bedeutet: Es gibt nicht nicht einen Realisierer
  für phi. In klassischer Logik ist das natürlich äquivalent dazu, dass es
  einen Realisierer für phi gibt. Wieder geht r gar nicht ein.

* Ein Realisierer a realisiert genau dann (neg neg phi --> phi),
  wenn aus der (nicht nicht) Realisierbarkeit von phi folgt, dass für alle
  Realisierer r gilt, dass ar |== phi.


=== Beispiele für Realisierbarkeitsübersetzungen

* "Es gibt eine Injektion phi : N^N --> N" bedeutet, dass es eine Injektion
  (Menge der berechenbaren Funktionen N --> N) --> N gibt, welche berechenbar
  ist: Gegeben ein Realisierer einer berechenbaren Funktion f : N --> N, soll
  die natürliche Zahl phi(f) produzieren.

  Das ist nicht möglich bei gewöhnlichen Turingmaschinen, wohl aber bei ITTMs.
  Definiere dabei phi(f) := min { n | die n-te ITTM berechnet f }.

* Genau dann gibt es einen Realisierer für "Jede Funktion N --> N ist entweder
  konstant Null oder an einer Stelle ungleich Null", wenn es ein Halteorakel
  gibt (genauer: ein Orakel, welches entscheidet, ob eine gegebene Maschine in
  endlich vielen Schritten hält). Die Aussage ist also nicht realisierbar im
  Fall gewöhnlicher Turingmaschinen, aber durchaus realisierbar bei ITTMs.

  Denn sei ein solcher Realisierer gegeben. Ist eine Maschine gegeben, welche
  auf Terminierung untersucht werden soll, dann befragen wir den Realisierer
  nach dem Konstantheitsstatus derjenigen Funktion, welche n schickt auf den
  Wahrheitswert, ob die Maschine nach n Schritten bereits angehalten hat.

  Umgekehrt können wir mit einem Halteorakel den Realisierer für die gegebene
  Funktion einfach nacheinander auf allen Eingaben laufen lassen.

* "Jede 0/1-Folge, welche nicht nur aus Nullen besteht, enthält eine Eins."
  (Markov) Das stimmt bei gewöhnlichen Turingmaschinen und bei ITTMs. Der
  Realisierer führt einfach eine unbeschränkte Suche durch.

* Auswahlaxiom: Man kann recht einfach zeigen, dass eine Assembly X genau
  dann projektiv ist, wenn es einen Realisierer r gibt, der kanonische
  Realisierer für die Elemente aus X berechnet: Ist a ein Realisierer eines
  Elements von X, so soll auch ra einer sein; und sind a und b Realisierer
  desselben Elements, so soll ra = rb sein.

* Die formale Church--Turing-These besagt: Jede Funktion N --> N ist
  durch eine Turingmaschine (äquivalent: einen λ-Term) gegeben. Im
  Realisierbarkeitsmodell durch Turingmaschinen ist sie trivialerweise erfüllt.
  Im Modell durchs λ-Kalkül dagegen nicht, da ein Realisierer nicht in gegebene
  λ-Terme hineinschauen kann.

  Als Konsequenz ist die Funktion N^N --> N/~, welche einer Funktion die
  Äquivalenzklasse von sie berechnenden Turingmaschinen zuordnet, nicht
  realisierbar im λ-Kalkül-Modell, wohl aber im TM-Modell.

* Was sind Beispiele für Aussagen, die im λ-Kalkül-Modell, aber nicht im
  TM-Modell realisierbar sind?

* TM können übrigens parallel-or, Lambda-Kalkül nicht. Das besagt wohl
  das Berry sequentiality theorem.
  http://lama.univ-savoie.fr/~hyvernat/Realisabilite2011/Files/JohnLongley1.pdf#page=26

* Vermutung von Longley und Phoa: Jedes Element einfachen Typs in PER(λC) ist
  PCF-definierbar.

* Es gibt Beispiele für propositionale Aussagen, die realisiert werden,
  aber nicht in Heyting-Arithmetik ableitbar sind: Rose 1953,
  https://www.ams.org/journals/tran/1953-075-01/S0002-9947-1953-0055952-4/S0002-9947-1953-0055952-4.pdf,
  Thm. 6.1. Ich verstehe aber die Notation nicht.

  Lässt man die Beschränkung auf propositionale Aussagen fallen, gibt es viele
  Beispiele: etwa die Negation der Aussage, jede Turingmaschine halte oder
  halte nicht.

* In Eff gibt es eine Folge rationaler Intervalle, die R überdecken
  und von beliebig kleinem Gesamtmaß sind.
  (https://webdpmms.maths.cam.ac.uk/~martin/Research/Oldpapers/hyland-effectivetopos.pdf)


=== In schwachen Metatheorien

* PRA zeigt:

      Falls HA die Sequenz (phi |- psi) im Kontext x_1, ..., x_n ableitet, so
      gibt es eine Zahl r mit

          HA |- (r ||= (forall x_1. ... forall x_n. (phi ==> psi))).

* PRA + "Turingmaschinen, die HA-beweisbar terminieren, terminieren" zeigt
  auch:

      Falls HA |- phi, so gibt es r mit HA |- (r ||= phi).

* PRA zeigt:

      Falls HA |- phi, so HA |- (exists r. r ||= phi).

* Update: Es hängt wohl davon ab, wie die Klauseln für ∃ und ∨ aussehen.
  Fordern die direkt die Existenz von Zeugen oder nur die Existenz von
  Turingmaschinen, die Zeugen berechnen könnten?

  Ich denke, dass, falls letzteres, schon PRA zeigt: Falls HA |- phi,
  so gibt es r mit HA |- (r ||= phi).

  Aber wieso betont das niemand?

* Mit der neuen Konvention geht der falsche Beweisversuch des
  Reflektionsprinzips nicht durch, wie es sollte:

  Gelte HA |- (HA |- phi). Dann gibt es r mit HA |- (r ||= (HA |- phi)).
  Also HA |- (r ist eine Turingmaschine, die mit einem HA-Beweis von phi
  terminiert). Daraus folgt aber nicht (in einer schwachen Metatheorie), dass
  HA |- phi.


=== Realisierung von IZF

* Man kann sogar eine Realisierbarkeitssemantik für IZF, inklusive
  nichtklassischer Prinzipien aber großer Kardinalzahlen (!) angeben.
  http://lama.univ-savoie.fr/~hyvernat/Realisabilite2011/Files/JohnLongley1.pdf,
  Seite 13.


=== Idempotenz von Realisierbarkeit

* Für jede HA-Formel phi gilt: HA + ECT_0 |- (phi <--> (|== phi)).

  Dabei ist ECT_0, für beliebige Formeln B(x,y) und "fast negativen" Formeln
  A(x) (aus "t = s", "exists x. t = s", top, bot, wedge, implies, forall
  zusammengesetzt):

      forall x. (A(x) --> exists y. B(x,y))
          --> exists e. forall x. (A(x) --> M_e(x) terminiert und B(x, M_e(x)))

* Daraus folgt: HA |- (|== phi) genau dann, wenn HA + ECT_0 |- phi.

  Die Rückrichtung ist klar, denn HA |- (|== ECT_0).

* Das hängt wohl eng mit einer Form von Idempotenz zusammen:

      |== (phi --> (|== phi)).

* Siehe /Extensional realizability/ von Jaap van Oosten, Seite 2.
  https://www.sciencedirect.com/science/article/pii/S0168007296000504


=== Krivine-Realisierbarkeit

* Krivine-Realisierbarkeit interpretiert klassische Logik und sogar ZF.
  Ziel (von wem?): Das auf ZFC ausdehnen.

* Krivines Philosophie ist: Neue Programmierkonzepte sollten dadurch motiviert
  werden, dass sie wichtige Axiome realisieren.
  http://lama.univ-savoie.fr/~hyvernat/Realisabilite2011/Files/JohnLongley1.pdf#page=18


=== Gleichmäßige Stetigkeit

In folgenden Topoi gilt, dass alle Funktionen vom Typ 2^N --> N gleichmäßig
stetig sind:

* Der Realisierbarkeitstopos zu Kleenes modifizierter Algebra.
  Zum Nachweis benötigt man aber ein Stückchen klassische Prinzipien in
  der Metatheorie.

* Der Topos der C-Räume von Chuangjie Xu (einem Schüler von Escardó):
  https://cj-xu.github.io/talks/xu-tlca2013.pdf
  https://cj-xu.github.io/talks/xu-kleene-kreisel.pdf


=== Effektiver Topos

Muss aus Asm(A) noch einen Tripos machen und daraus einen Topos.
Dabei wird Gleichheit dann nicht mehr trivial realisiert.


=== Untertopoi des effektiven Topos

* Sei A <= N. Sei k_A der kleinste modale Operator im effektiven Topos,
  der Entscheidbarkeit von A erzwingt.

  Dann ist k_A <= k_B genau dann, wenn A Turing-reduzierbar zu B ist.

  https://webdpmms.maths.cam.ac.uk/~martin/Research/Oldpapers/hyland-effectivetopos.pdf,
  Seite 36.


=== Berechenbarkeit von Lösungen von Differentialgleichungen

* Pour-el, Richards. A computable ordinary differential equation which
  possesses no computable solution.
  http://www.sciencedirect.com/science/article/pii/0003484379900214


=== 2-kategorielle Aspekte der Tripos-zur-Topos-Konstruktion

* https://www.lama.univ-savoie.fr/~hyvernat/Realisabilite2009/Files/Jonas_Frey.pdf
  https://arxiv.org/abs/1104.2776

* https://arxiv.org/abs/1401.7867


=== Ein Realisierbarkeitstopos über beweisbar haltende Turingmaschinen?

* Man könnte denken, dass es eine PCA gibt, in der wir definieren: e * n
  ist genau dann definiert, wenn e von der Form <r,p> ist, wobei p ein
  ZFC-Beweis ist, dass r eine stets terminierende Turingmaschine ist; in diesem
  Fall sei e * n = r(n).

* Aber den Kombinator S kann man nicht bauen. Der wäre in etwa so:

    Lese <f,p> ein.
    Prüfe, dass p ein Terminierungsbeweis von f ist. (Andernfalls halte.)
    Gib folgende TM (zusammen mit einem Terminierungsbeweis) aus:

        Lese <g,q> ein.
        Prüfe, dass q ein Terminierungsbeweis von g ist. (Andernfalls halte.)

        Gib folgende TM (zusammen mit ...) aus:

            Lese x ein.
            Berechne g(x).
            Berechne f(x).
            Berechne f(x)(g(x)).

                  Für den letzten Schritt brauche ich eine UTM!
                  Aber da ZFC ZFC-Beweisen misstraut, kann ich keinen
                  ZFC-Terminierungsbeweis der UTM angeben.


=== Quellen

* http://math.andrej.com/data/c2c.pdf
* http://www.mathematik.tu-darmstadt.de/~streicher/REAL/REAL.pdf
* http://math.andrej.com/wp-content/uploads/2014/03/real-world-realizability.pdf
* https://arxiv.org/abs/1401.7867
* http://www.lfcs.inf.ed.ac.uk/reports/92/ECS-LFCS-92-208/ von Wesley Phoa
  (sehr empfohlen von Michael O'Connor, Todd Trimble und Tom Leinster)
* https://webdpmms.maths.cam.ac.uk/~martin/Research/Oldpapers/hyland-effectivetopos.pdf
