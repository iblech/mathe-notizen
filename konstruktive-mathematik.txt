* Effektive Homotopietheorie:
  http://arxiv.org/pdf/1105.6257v3.pdf

* Berechenbare Mathematik = Realisierbarkeitsinterpretation konstruktiver Mathematik
  http://math.andrej.com/data/c2c.pdf

* Mal lesen: https://arxiv.org/pdf/1511.01113.pdf
  "Unreliability of the logical principles"


=== Lustige Situation in Ringen

Sei R ein Ring und seien a,b,c Ringelemente. Gelte a,b,c != 0.
Gelte ferner abc = 0.

Dann ist klar: R kann kein Integritätsbereich sein. Aber Nullteiler kann man
auch nicht explizit angeben:

* Sollte ab  = 0 sein, so ist (a,b)  ein Nullteiler.
* Sollte ab != 0 sein, so ist (ab,c) ein Nullteiler.

Welcher Fall vorliegt, kann man aber nicht entscheiden.


=== Ein Lemma über viele Aussagen

Seien Aussagen phi_ij mit i = 1, ..., n und j = 1, ..., m_i gegeben;
dabei n >= 1 und alle m_i >= 1.

Gelte: forall j_1. ... forall j_n. exists i. phi_{i, j_i}.

Dann: exists i. alle phi_{i, *} gelten.

Beweis durch Induktion über n; Induktionsanfang n = 1 klar. Der
Induktionsschritt n --> n + 1 geht so: Definiere Aussagen

    psi_ij := (phi_ij  oder  alle phi_{n+1, *} gelten)
        für i = 1, ..., n.

Diese Aussagen erfüllen die Voraussetzung:

    Seien j_1, ..., j_n beliebig. Nach Voraussetzung an die phi_ij
    erhalte dann für jeden Index j_{n+1} = 1, ..., m_{n+1} einen Index i
    mit phi_{i, j_i}. Falls dieser Index i immer n + 1 sein sollte, dann habe
    psi_{1, j_1}. Falls er auch nur einmal <= n sein sollte, dann habe psi_{i, j_i}.

Nach Induktionsvoraussetzung gibt es also ein i <= n sodass alle psi_{i, *}
gelten. Bin damit fertig.


=== Epimorphismen in der Kategorie der Gruppen

* https://golem.ph.utexas.edu/category/2015/08/wrangling_generators_for_subob.html#c049544
* http://ncatlab.org/nlab/show/epimorphisms+of+groups+are+surjective


=== Kompaktifizierung der natürlichen Zahlen

N* := { (x_n)_n | x_n in {0,1}, (x_n) monoton steigend }.

* N* ist die *finale Koalgebra* zum Funktor 1 + (__).

  Die Koalgebrenstruktur wird gegeben durch

      (x_n) |--> falls x_0 = 1: *, sonst: (x_(n+1)).

* Unendlich wird dargestellt durch

      (0,0,0,...),

  natürliche Zahlen durch

      (0,...,0, 1,...).

* Die Ordnung eines Elements in einem diskreten Monoid ist in natürlicher
  Weise ein Element dieser vervollständigten natürlichen Zahlen.

* Konsequenterweise ist auch die Charakteristik eines diskreten Rings
  eine solche Zahl.


=== Kohomologie diskreter Räume

http://homotopytypetheory.org/2013/07/24/cohomology/
Andreas Blass (_Cohomology detects failures of the axiom of choice_)
http://mathoverflow.net/questions/12119/reverse-mathematics-of-cohomology


=== Eindeutigkeit impliziert Existenz

* Wenn eine Funktion näherungsweise Nullstellen hat (forall eps. exists x. |f(x)| < eps)
  und gleichförmig höchstens eine Nullstelle hat, so hat sie wirklich eine.

  Peter Schuster. Problems, Solutions, and Completions.
  http://www.sciencedirect.com/science/article/pii/S1567832609000137

* Anders sieht es aus, wenn wir nicht mit "nicht nicht" die Aussage
  abschwächen, sondern mit der propositionalen Abschneidung ("merely",
  "anonymously")! Siehe Seite 2 von https://arxiv.org/pdf/1610.03346.pdf:

      On the other hand, should A have only one inhabitant up to the internal
      equality, this inhabitant can be constructed from an inhabitant of ||A||.
      This is a crucial difference between propositional truncation and double
      negation.


=== Nullstellensatz konstruktiv

* Es geht um folgende Behauptung: Sei k ein algebraisch abgeschlossener
  geometrischer Körper. Seien f_1, ..., f_m Polynome über k. Dann besitzen die
  f_j eine gemeinsame Nullstelle oder 1 in (f_1, ..., f_m).

  Ich glaube, dass man diesen Satz wie folgt konstruktiv zeigen kann.
  Zunächst zeigt Theorem VII.1.8 (Seite 386) von Lombardi/Quitté, dass
  1 in (f_1, ..., f_m) oder dass es eine gemeinsame Nullstelle in einer
  reduzierten endlichen k-Algebra A mit 1 != 0 gibt.

  Da k ein algebraisch abgeschlossener geometrischer Körper ist, ist k
  auch fppf-lokal. Trivialerweise ist A flach über k. Ich denke, man kann auch
  zeigen, dass A treuflach über k ist. Somit liftet die Nullstelle in A zu
  einer in k.

  Allerdings nutzt das jetzt aus, dass k in einem starken Sinn fppf-lokal ist.
  Klassisch auf jeden Fall okay. Konstruktiv weiß ich's nicht.

* Theorem VII.1.9 nutzt Gröbnerbasen. Braucht man dann nicht sowas wie LPO
  oder Markov oder das abhängige Auswahlaxiom? Lombardi/Quitté haben keine
  Angst vor ihm!

* Jedenfalls muss es einen konstruktiven Beweis geben. Weil die Behauptung
  eine geometrische Implikation ist.


=== Type-2 Theory of Effectivity

* Ziegler, Brattka: A computable spectral theorem.
  https://pdfs.semanticscholar.org/a669/d482836f92827fd98d4c266489b54b9f0183.pdf

  Hier wird wiederholt, welche Operationen aus der linearen Algebra alle
  berechenbar (oder zumindest von unten oder oben approximierbar) sind:
  Kern, Spann, ...

* Die stetige Familie exp(-1/eps^2) [cos(2/eps), sin(2/eps); sin(2/eps), -cos(2/eps)]
  von reellen symmetrischen Matrizen (mit der Nullmatrix im Fall eps = 0)
  zeigt, dass die Berechnung von Eigenbasen nicht stetig ist.

  Für eps != 0 erhält man nämlich die Basen

      (cos(1/eps), sin(1/eps)), (sin(1/eps), -cos(1/eps))

  (bis auf Reihenfolge und Orientierung).

  Das Beispiel stammt von Rellich. Siehe Proposition 12 in Ziegler/Brattka für
  Details.

* Weihrauch, Computable Analysis.


=== Reelle Zahlen

* Was ich im Softwareprojekt gemacht habe, steht teilweise auch in (aber mit
  Cauchyfolgen statt Cauchyprozessen): Real Numbers, Generalizations of the
  Reals, and Theories of Continua herausgegeben von P. Ehrlich


=== Noetherianität

* Coquand und Lombardi (Foliensatz /Krull's Principal Ideal Theorem/)
  definieren die Noetherianität eines Rings wie folgt.
  http://www.mittag-leffler.se/sites/default/files/IML-0001-30.pdf

  Bedeute G(x_0,...,x_{n-1}), dass ein i < n mit x_i in (x_0,...,x_{i-1})
  existiert. G() ist falsch.

  Ein Ring ist genau dann noethersch, wenn für jedes Prädikat P über endliche
  Folgen von Ringelementen mit

      1. G(sigma) ==> P(sigma)
      2. P(sigma) ==> P(sigma,x)
      3. (forall x. P(sigma,x)) ==> P(sigma)

  gilt: P(sigma) für alle sigma.

* Wenn (x_1,...,x_n) = (1), so gilt P(x_1,...,x_n) für solch ein Prädikat.

* G(x_1,...,x_n) bedeutet, dass (x_1) <= (x_1,x_2) <= ... <= (x_1,...,x_n)
  *keine* echt aufsteigende Kette von Idealen ist.

* In diesem Sinn ist Z noethersch. Es genügt, P(x) für alle x in Z
  nachzuweisen. Der Fall P(0) ist klar, da G(0). Sei N die Gesamtzahl
  Primfaktoren (mit Vielfachheiten gezählt) in x. Dann gilt für alle
  k <= N und alle a_1,...,a_k: G(x,a_1,...,a_k) oder (x,a_1,...,a_k) = (1).
  Somit folgt P(x).

* Angeblich ist mit dieser Definition R[X] noethersch, falls R noethersch ist.

* Oft definiert man P(sigma) als (G(sigma) vee phi).

* In klassischer Logik kann man wie folgt einsehen, dass CL-Noetherianität
  dasselbe wie die übliche Bedingung ist.

  "==>": Definiere P(a_0,...,a_{n-1}) als "jede aufsteigende Kette von endlich
  erzeugten Idealen, die mit (a_0) <= (a_0,a_1) <= ... <= (a_0,...,a_{n-1})
  beginnt, hält".

  "<==": Wenn P() nicht gilt, kann man sukzessive eine Folge (a_0,...)
  konstruieren, sodass für kein n P(a_0,...,a_{n-1}) gilt. Aber irgendwann ist
  G(a_0,...,a_{n-1}) erfüllt.

* Die CL-Bedingung impliziert meine Prozessbedingung -- allerdings nicht für
  Prozesse, die Ideale ausgeben, sondern für Prozesse, die Folgen von
  Ringelementen ausgeben. Wobei die Folge im nächsten Schritt immer eine um
  genau ein Element ergänzte Folge sein muss.

  Definiere dafür P(a_0,...,a_{n-1}) als "jeder Prozess in diesem Sinn,
  für den es einen initialen Ablauf der Form () <= (a_0) <= ... <=
  (a_0,...,a_{n-1}) gibt, hält".

  Man kann die CL-Bedingung auch abändern, sodass die sigma's nicht mehr Folgen
  von Elementen, sondern Folgen von endlich erzeugten Idealen sind. Das
  Prädikat G definiert man dann als

      G(I_0,...,I_{n-1}) :<==> exists i < n. I_0 + ... + I_{i-1} = I_0 + ... + I_i.

  Die veränderte CL-Bedingung impliziert meine Prozessbedingung in ihrer
  unveränderten Form.

  Man kann die CL-Bedingung auch durch eine negative Variante ersetzen:

      1. Q(sigma) ==> neg G(sigma)
      2. Q(sigma a) ==> Q(sigma)
      3. Q(sigma) ==> exists a. Q(sigma a)

      Ring noethersch genau dann, wenn für all solchen Prädikat gilt: neg Q().

  Ein Ring, der diese Bedingung erfüllt, hat dann die Eigenschaft, dass kein
  Prozess nicht hält. (Definiere Q(sigma) :<=> "es gibt einen Prozess, für den
  ein Anfangsablauf wie von sigma vorgeschrieben existiert, der nicht hält".)
  (Bis auf Ideal/Element-Unterschied.)

* Es gibt auch die Noether-Bedingung von Richman und Seidenberg:
  aufsteigende Folgen von endlich erzeugten Idealen stoppen.

  Hervé Perdry schreibt in /Strongly Noetherian rings and constructive ideal
  theory/: Ist R kohärent und RS-noethersch, so ist auch R[X] kohärent und
  RS-noethersch. Außerdem hat R[X] herauslösbare Ideale, falls R sie hat.

* Meine alte Definition von "processly Noetherian" war Quatsch. Zur Erinnerung:
  Ein Prozess in einer partiell geordneten Menge X war eine Funktion f : N --> P(X)
  sodass f(0) bewohnt ist und sodass für alle n und x aus f(n) ein y aus f(n+1)
  mit x <= y existiert. So ein Prozess heißt haltend, wenn es ein n und ein x
  gibt, sodass x in f(n) und in f(n+1) liegt.

  Das Problem dabei ist, dass die Zugehörigkeit von x zu f(n) und f(n+1) nicht
  ausdrückt, dass x ist ein möglicher Fixpunkt des f zugrundeliegenden
  (gedachten) iterativen Entstehungsprozesses ist.

* Richman spricht ja in http://math.fau.edu/richman/Docs/new-acc.pdf über die
  ascending tree condition. Die ist super! Und identisch mit der Bedingung, die
  ich eigentlich im Sinn hatte. Nämlich:

  Ein Prozess in X ist ein Tupel (x0, phi) mit x0 in X und phi : X --> P(X).
  Dabei muss phi erfüllen:

      0. Für alle y aus phi(x) ist x <= y.
      1. phi(x0) ist bewohnt.
      2. Für alle x1 aus phi(x0) ist phi(x1) bewohnt.
      3. Für alle x1 aus phi(x0) und x2 aus phi(x1) ist phi(x2) bewohnt.
      4. Und so weiter.

  Dabei könnte oder sollte man 0. so abschwächen, dass es nur noch über die
  von x0 aus erreichbaren Ergebnisse spricht.

  Ein solcher Prozess hält, wenn es eine Abfolge x1, x2, ..., xn mit

      x_(i+1) in f(x_i) für i = 0, ..., n-1  und  x_n in f(x_n)

  gibt.

  Die Äquivalenz zu Richmans Definition sieht wie folgt aus.

  Sei (x0, phi) ein Prozess. Betrachte die durch Erweiterung geordnete
  Partialordnung aller endlichen Abläufe dieses Prozesses. Diese Partialordnung
  ist ein Baum. Definiere eine Familie J auf diesem Baum durch J_[x0,...,xn] := xn.
  Nach Voraussetzung hält J. Also gibt es [x0,...,xn] < [y0,...,ym] mit xn = ym.
  Nach Definition der Ordnung ist [y0,...,ym] = [x0,...,xn,x_(n+1),...,x_m].
  Also xn = x_(n+1).

  Sei J ein auf einem Baum I definierte Familie. Definiere den Prozess
  (bot in I, phi) mit

      phi(x) := { y | exists i < j: x = J_i, y = J_j }.

  Der so definierte Prozess hält. Also gibt es i < j mit J_i = J_j. Also hält J.

* Die alte komische Prozessbedingung wird von der neuen guten impliziert.
  Aber umgekehrt nicht. Komisches Halten aller komischen Prozesse impliziert
  nicht richtiges Halten aller richtigen Prozesse.

* Man könnte sich bei Richmans und der neuen Prozessdefinition fragen:
  Ist es nicht komisch, dass man nur fordert, dass *irgendein* Ablauf hält?
  Sollte man das nicht für Abläufe tun?

  Tatsächlich aber halten auch alle Abläufe. Schließlich ist ein Teilbaum eines
  Baums wieder ein Baum, der ebenfalls halten muss.

  Bisschen komisch ist es trotzdem.

* Wie sieht's im Computer aus? Soll ein Zeuge der Noetherianität alle möglichen
  Abläufe eines Algorithmus durchgehen? Natürlich nicht. Er beschränkt sich auf
  irgendeinen. Dieser muss ja ebenfalls halten. Hat wohl damit etwas zu tun,
  dass "im Computer das abhängige Auswahlaxiom gilt".

* Ist X ein lokal noethersches Schema, so ist O_X kohärent. Denn:

  1. Klassisch folgt aus Noetherianität Kohärenz.
  2. Ist M kohärent, so auch M~.

  Als Korollar hat man auf lokal noetherschen Schemata: Endlich erzeugte
  Untermoduln von O_X sind schon quasikohärent. Denn da O_X kohärent ist, sind
  endlich erzeugte Untermoduln von O_X schon endlich präsentiert. Und endlich
  präsentierte Moduln sind quasikohärent. (Hier geht der einfache Fakt ein,
  dass endlich erzeugte Untermoduln von kohärenten Moduln kohärent sind.)

  Dieses Korollar gilt auch völlig allgemein. Ein endlich erzeugter Untermodul
  von O_X ist das Bild eines Morphismus der Form O_X^n --> O_X.

* "Witzig": O_X erfüllt genau dann eine "schlechte Noetherianitätsbedingung",
  wnn es eine "gute Noetherianitätsbedingung" erfüllt. Denn man hat Äquivalenz
  zur klassischen Welt und dort sind alle Bedingungen gleich.

  Intern hat man auch: Ist O_X noethersch, so ist O_X kohärent. Obwohl diese
  Folgerung konstruktiv nicht zulässig ist.

  Was gilt in einer konstruktiven Meta-Theorie? Vielleicht sowas: Ist A
  kohärent und noethersch so ist O_{Spec A} kohärent und noethersch. Wobei der
  Verzicht auf Kohärenz jeweils nicht möglich ist.


=== Analysis

http://www.phil.pku.edu.cn/cllc/people/fengye/finitismAndTheLogicOfMathematicalApplications.pdf

Hochgelobt von David Roberts auf MO.


=== Generische Freiheit

* Generische Freiheit für Moduln:

  Let R be a reduced ring. Let A be a finitely generated R-module. Assume
  that the only f in R such that A[f^(−1)] is a finitely free R[f^(−1)]-module
  is f = 0. Then R = 0.

  http://mathoverflow.net/questions/250040/constructive-proof-that-a-kernel-consists-of-nilpotent-elements

* Und für Algebren:

  Lemma 1: Sei R ein Ring. Sei M ein R-Modul mit Erzeugendensystem
  (x_i)_{i in I}. Sei I total geordnet. Gelte für alle g in R:
  Ist in M[g^{-1}] einer der Erzeuger R[g^{-1}]-Linearkombination von
  anderen Erzeugern mit kleinerem Index, so ist g = 0. Dann ist M frei mit
  (x_i)_i als Basis.

  Beweis: Sukzessive von höheren zu niedrigeren Indizes den Beweis von
  Lemma 1 in der MO-Antwort anwenden.

  Lemma 2:
      Sei R ein reduzierter Ring. Sei S eine R-Algebra von endlichem Typ.
      Sei M ein endlich erzeugter S-Modul.

      Gelte für alle f aus R: Sollte M[f^{-1}] (nicht notwendigerweise
      endlich) frei über R[f^{-1}] sein, so ist f = 0.

      Dann ist R = 0.

  Beweis: Sei S als R-Algebra durch x_1, ..., x_m erzeugt. Sei M als S-Modul
  durch v_1, ..., v_l erzeugt. Dann ist das System aller Vektoren der Form
  x_1^{i_1} ... x_m^{i_m} v_j ein Erzeugendensystem von M als R-Modul. Wir ordnen
  die Menge aller Indizes (j, i_1,...,i_m) lexikographisch.

  Wir führen nun eine Induktion über die Struktur eines "schönen
  Erzeugendensystems" von M als R-Modul. Wir möchten sukzessive
  überflüssige Elemente aus einem solchen System entfernen, bis wir bei
  einer Basis landen.

  Ein schönes Erzeugendensystem soll ein Untersystem des trivialen
  Erzeugendensystems bestehend aus allen Vektoren der Form
  x_1^{i_1} ... x_m^{i_m} v_j sein, das folgende kritische Eigenschaften hat:

  a) Wenn einer dieser Vektoren nicht Teil des Systems ist, dann sind
     auch alle Vektoren mit noch größeren x_i-Potenzen nicht Teil des
     Systems.

  b) Jeder Vektor der Form x_1^{i_1} ... x_m^{i_m} v_j ist
     Linearkombination von Vektoren aus dem System, deren Index jeweils
     kleiner als (j, i_1,...,i_m) ist.

  Eigenschaft a) stellt sicher, dass ein Induktionsbeweis zulässig ist.
  Wenn man beliebige Erzeugendensysteme erlaubt, kann es nämlich sein,
  dass man unendlich oft überflüssige Vektoren aus dem System entfernen
  muss und danach immer noch nicht bei einer Basis landet. Dagegen gibt es
  keine unendlichen absteigenden Ketten in der Menge aller schönen
  Erzeugendensysteme.

  Eigenschaft b) ist nötig, damit der Induktionsschritt durchgeht.

  Der Induktionsanfang, bei dem das gegebene schöne Erzeugendensystem das
  leere System ist, ist schnell erledigt: Dann ist M = 0. Indem wir die
  Voraussetzung für f := 1 verwenden, sind wir fertig.

  Im Induktionsschritt sei ein schönes Erzeugendensystem gegeben.
  Wir möchten die Voraussetzungen von Lemma 1 überprüfen (dann können wir,
  indem wir die Voraussetzung für f := 1 verwenden, den Beweis
  abschließen).

  Sei also ein beliebiges Element g in R gegeben, sodass über R[g^{-1}]
  einer der Vektoren aus dem gegebenen schönen Erzeugendensystem
  Linearkombination von Vektoren mit kleinerem Index ist. Dann lässt sich
  M[g^{-1}] über R[g^{-1}] durch ein echt kleineres schönes
  Erzeugendensystem erzeugen (einfach den überflüssigen Vektor sowie all
  seine x_i-Vielfache streichen und nachprüfen, dass das entstehende
  Erzeugendensystem wieder schön ist). Nach Induktionsvoraussetzung ist
  R[g^{-1}] = 0. Also ist g = 0.

* Aus interner Sicht ist das alles etwas einfacher. Im kleinen Zariskitopos
  von Spec(R) gilt für alle Elemente f der Strukturgarbe:

      neg neg (f = 0  vee  f invertierbar).

  Dann eine Induktion über die Struktur eines "schönes Erzeugendensystems",
  um nachzuweisen, dass M~ nicht nicht frei ist. Wir haben:

      neg neg (ein Erzeuger ist Linearkombination von kleineren  oder  nicht).

  Da wir eine doppelt negierte Aussage beweisen möchten, können wir davon
  ausgehen, dass die Aussage in Klammern stimmt. Im zweiten Fall ist das
  Erzeugendensystem linear unabhängig. Im zweiten Fall können wir die
  Induktionsvoraussetzung auf das verkleinerte System anwenden.

  Genauer geht es hier immer um "Freiheit über einer endlichen Menge oder einer,
  die bijektiv zu N ist". Das ist auch wichtig, denn sonst können wir nicht
  folgern, dass die Modulgarbe lokal frei ist.


=== Algebraische Abgeschlossenheit

* Die dedekindschen komplexen Zahlen sind im Allgemeinen nicht algebraisch
  abgeschlossen. Etwa nicht im Garbentopos über [0,1]. Dort sind sie gegeben
  durch die Garbe der stetigen komplexwertigen Funktionen. Aber das Polynom
  X^2 - w, wobei w die Funktion ist, die immer schneller und immer kleiner um 0
  herum kreist, hat in der internen Sprache keine Nullstelle.

* Die cauchyschen komplexen Zahlen sind algebraisch abgeschlossen.
  Wim Ruitenburg. Constructing roots of polynomials over the complex numbers.
  http://www.mscs.mu.edu/~wimr/publica/roots_new.pdf
