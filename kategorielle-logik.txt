* http://ljk.imag.fr/membres/Dominique.Duval/Slides/capp10.pdf
* A categorical semantics of quantum protocols: http://arxiv.org/abs/quant-ph/0402130

* Ein altes Paper:
  Michael Fourman, Continuous Truth I.


=== Zusammenhang zwischen [[.]] und |==

Siehe Shulmans Stack-Paper. Sei phi eine Aussage über einem Topos E mit einer
freien Variable x. Dann definiert die Kripke-Joyal-Interpretation von phi eine
Prägarbe auf E, nämlich

    A |--> { a : A --> X | A |== (a^* phi)[x/a] }.

Das ist eine Unterprägarbe von Hom(__, X). Diese nun wird dargestellt durch

    [[x:X. phi]].

NB: Diese Unterprägarbe ist sogar eine Garbe, also ein richtiges Unterobjekt in
Sh(E). Das klärt ein wenig die Bezeichnung "Stack-Semantik".


=== Schnitte von [[x:X. phi]] in einem Garbentopos Sh(Y)

Die U-Schnitte von [[x:X. phi]] gerade diejenigen U-Schnitte von X, die in der
Kripke-Joyal-Semantik die Aussage phi erfüllen. (Wende dazu den genannten
Zusammenhang auf A := Hom(__,U) an.)

* Die Formel "forall y. xy = 0 ==> x = 0" (d.h. "x ist regulär") ist nicht
  geometrisch. Trotzdem kann man einfach angeben, wie das Unterobjekt der
  regulären Elemente einer Ringgarbe R aussieht:

      Reg_R(U) = { x \in R(U) | U |== phi(x) }
               = { x \in R(U) | x regulär in allen R_p, p \in U }.

  Denn für festes x ist phi(x) eine geometrische Sequenz.


=== Schnitte von [[ { x:X | phi } ]] in einem Garbentopos Sh(Y)

Betrachte das Pullbackdiagramm

    [[ x:X. phi ]] --------> 1
         |                   |
         |                   |
         |                   |
         v                   v
         X --------------> Omega  (das ist, modulo Curryfizierung,
                 chi              die Interpretation [[ {x|phi} ]])

auf U-Schnitten; da Schnitte nehmen linksexakt ist, bleibt das ein
Pullbackdiagramm. Da aber Omega(U) nicht viel mit der externen Menge der
Wahrheitswerte zu tun hat, lässt sich chi_U nicht als klassifizierende
Abbildung einer Teilmenge von X(U) lesen.

Es gilt zumindest für alle s aus X(U): chi_U(s) = U <==> U |== phi[s/x].


=== Geometrische Formeln und Konstruktionen

* Geometrische Formeln vertragen sich gut mit dem Zurückziehen längs
  geometrischer Morphismen:

      f^* [[phi]] = [[f^*(phi)]].

* Mittels Induktion über den Formelaufbau kann man leicht folgendes zeigen:
  Sei phi eine geometrische Formel über eine Teilmenge U. Sei x in U.
  Dann gilt:

      Set |== x^* phi   <==>   ex. x \in V \subseteq U: V |== phi.

  Falls phi auch "==>" oder "forall" enthält, gilt nur "<==" -- allerdings nur
  dann, wenn man noch die volle Induktionsvoraussetzung für alle Teilaussagen
  zur Verfügung hat. Wegen der Charakterisierung der Gültigkeit geometrischer
  Sequenzen ist die Rückrichtung aber sowieso trivial.

  Die Äquivalenz gilt auch, wenn Teilaussagen der Form "x \in A" für
  Teil"mengen" A \subseteq M vorkommen. Die muss man allerdings richtig
  verstehen: Nicht die Menge A als globales Element von [M, Omega] auffassen,
  sondern als Untergarbe von M. Wenn A selbst über eine geometrische Formel
  definiert wurde, kann man auch gut angeben, wie die zurückgezogene Untergarbe
  x^* A aussieht.

* Damit ist es leicht, zu zeigen, dass eine geometrische Sequenz genau
  dann auf einer offenen Teilmenge U gilt, wenn sie an allen Halmen gilt.

* Eine *Konstruktion* heißt geometrisch, wenn sie sich nur aus Dingen
  zusammensetzt, die unter solchen Rückzügen erhalten bleiben, insbesondere
  sind das Produkt und Koprodukt, aber auch Interpretationen von geometrischen
  Formeln (nicht Sequenzen!).

* Etwa ist R^x := { x:R | exists y:R. xy = 1 } eine geometrische Konstruktion,
  Reg(R) := { x:R | forall y:R. xy = 0 ==> y = 0 } aber nicht.

* Objekte natürlicher Zahlen und Listenobjekte kommutieren mit Rückzug.

* Die Konstruktion "freier R-Modul auf" kommutiert ebenfalls. Das ist NICHT
  klar, wenn man dazu die feinste Äquivalenzrelation mit ... verwendet,
  aber SCHON, wenn man ihn einfach als Koequalizer definiert:

      Rel ==> L(R x X) --> coeq,

  wobei Rel = { (v,w) | v,w sind mit einer elementaren Umformung miteinander
  verbunden }. Die beiden Morphismen aus Rel sind die beiden
  Projektionsmorphismen. Denn Koequalizer, Rel und L sind alle geometrisch.

* Auch die Konstruktion "Kählerdifferentiale" ist geometrisch.

* Rückzug von Örtlichkeiten funktioniert, ist aber nicht ganz trivial:
  Siehe Spitters/Vickers/Wolters, Gelfand spectra in Grothendieck toposes using
  geometric mathematics, http://arxiv.org/pdf/1310.0705.pdf.

* Die Hom-Konstruktion ist im Allgemeinen nicht geometrisch, aber schon, wenn
  der vordere Modul von endlicher Präsentation ist. Siehe meine Antwort auf
  StackExchange: http://math.stackexchange.com/questions/16203/why-doesnt-hom-commute-with-taking-stalks/645385#645385


=== Generischer Halm

Sei xi ein generischer Punkt eines topologischen Raums X. Das soll heißen, dass
der Abschluss von {xi} ganz X ist. Dann gilt: Jede nichtleere offene Teilmenge
enthält xi. Daher folgt für eine geometrische Formel phi über X:

    phi gilt am generischen Halm  <==>
    phi gilt auf einer dichten offenen Teilmenge von X.

In diesem Sinn ist zu einem lokal geringten Raum (X,O_X) die "Keim-Umgebung"
(pt,O_{X,x}) also nicht nur in einem geometrischen Sinn keimartig, sondern auch
in einem logischen.

Verallgemeinerung: Sei xi ein Punkt, sodass der Abschluss von {xi} eine Menge A
ist. Dann gilt: Jede nichtleere offene Teilmenge von A enthält xi. Somit gilt
für geometrische Formeln phi über X:

    phi gilt am Halm xi  <==>
    phi gilt auf einer offenen Menge, die xi enthält  <==>
    phi gilt auf einer dichten offenen Teilmenge von A
        (ziehe hier phi längs A ^--> X zurück und rede
        dann in der internen Sprache von Sh(A))


=== Sh_j(E) vs. Sh(E) mit j-Übersetzung

* Gelte für einen modalen Operator Box:

      (Box phi)^Box = Box(phi^Box).

  Dabei bezeichnet (__)^Box die Box-Übersetzung (nur auf Formeln, ohne Änderung
  der Objekte).

  Das ist erfüllt für folgende Operatoren:

  * Box = negneg.
  * Box = (__ --> alpha) --> alpha.
  * Box = alpha --> __.
  * Box = __ v alpha.

  Wenn diese Bedingung erfüllt ist, so fühlt sich Box unter die Box-Übersetzung
  wie die Identität an:

      (Box phi ==> phi)^Box

    = (Box phi)^Box ==> phi^Box

    = Box(phi^Box) ==> phi^Box, das ist stets richtig.

  Das ist wohl einer der Gründe, wieso man bei der Box-Übersetzung nicht die
  Objekte vergarbifizieren muss: Sie fühlen sich schon garbifiziert an!

* Im Allgemeinen ist der Vergissfunktor Sh_j(E) --> Sh(E) ja nur linksexakt.
  Was bringt die Ableitung dieses Funktors (etwa auf abelschen Gruppen)?
  Etwa im Fall Set_negneg --> Set?
  Wie sieht die aus?
  Was bringt das im Fall j = ((__ --> !x) --> !x)?

  Ein explizites Modell sieht so aus, über Ext^1(ZZ, __),
  wobei ZZ die konstante Garbe ZZ bezeichnet:

  Zu einer kurzen exakten Sequenz 0 --> X --> Y --> Z --> 0 in Sh_j(E)
  (also j-gibt es zu jedem z:Z ein Urbild) gehört die Sequenz

      0 --> X -f-> Y -g-> Z --> Ext^1(ZZ,X)

  in E, mit Ext^1(ZZ,X) = { [0 --> X --> ? --> ZZ --> 0 j-exakt] }.
  Die Dimensionsshiftabbildung sieht so aus:

      z |--> [0 --> X --> { (y,r) | g(y) = rz } --> ZZ --> 0].

  Diese Sequenz ist tatsächlich j-exakt.


* Welche Bedeutung hat es, mit (__)^j zu arbeiten, aber über Objekte
  von E zu sprechen? Klingt erstmal so, als ob man Garbensprache verwenden
  würde, um über Prägarben zu sprechen. Das wäre ja nicht sound.
  Aber vielleicht arbeitet man tatsächlich automatisch mit den assoziierten
  Garben.


=== Bemerkungen, die konsolidiert werden müssen

* "Set |== x^* phi   <==>   ex. x \in V subseteq U: V |== phi."

  Das gilt nicht für das "große E", also unbeschränkte Quantifikation.
  Die Hinrichtung passt noch. Aber nicht die Rückrichtung.

  Es sei denn, man schränkt sich auf lokal konstante Garben ein.

* "X |== forall A. (phi --> psi)  <==>  f.a. x \in X, Mengen A: phi_x --> psi_x."

  Das stimmt, für geometrische phi, psi.

* Sei X mit folgender Eigenschaft: Jede offene Teilmenge lässt sich durch
  komapkte offene Teilmengen überdecken. Das ist etwa für Schemata erfüllt!

  Sei phi eine solche Aussage, sodass für jede kompaktoffene Teilmenge U
  gilt: U cap [phi] ist wieder kompakt.

  Das ist etwa für phi = "f invertierbar" auf einem Schema erfüllt!

  Dann gilt folgendes logisches Prinzip:

      X |== (phi --> bigvee_i psi_i) --> bigvee_i (phi --> psi_i),

  wobei (psi_i) eine monotone Familie über eine gerichtete Indexmenge ist.


=== Sh(X) boolsch

* Sh(X) ist genau dann boolsch, wenn für jede offene Teilmenge U gilt:
  U ist die einzige offene dichte Teilmenge von U.

* Sei X ein T1-Raum, d.h. für je zwei verschiedene Punkte existiert eine
  offene Menge U, die den einen, aber nicht den anderen Punkt enthält.
  (Das ist äquivalent dazu, dass alle Punkte abgeschlossen sind. Schemata sind
  also im Allgemeinen nicht T1! Ein Spektrum eines Rings ist genau dann T1,
  wenn der Ring <=null-dimensional ist.)

  Dann gilt: Sh(X) ist boolsch <==> X ist diskret.

  "<==": Sei V in U offen, dicht. Sei x in U. Dann {x} \subseteq U offen,
  nichtleer. Also V cap {x} != {}. Also x in V.

  "==>": Sei x in X. Angenommen, {x} ist nicht offen.
  Setze U := bigcup { V | V offen mit x nicht in V } = int(X \ {x}).
  Dann ist U dicht in X: Sei W offen, nichtleer. Dann muss ein y in W
  existieren, das nicht gleich x ist. (Denn enthielte W nur x, so wäre {x}
  offen.) Nach T1-Voraussetzung existiert dann eine offene Menge V, die y aber
  nicht x enthält. Daher ist der Schnitt U cap W nicht leer: Er umfasst V cap W,
  und diese Menge enthält y.
  Somit ist U = X. Das ist ein Widerspruch.


=== Reelle Zahlen

* Dedekindsche reelle Zahlen: Garbe der stetigen reellwertigen Funktionen.
* Cauchy-Zahlen: Garbe der lokal konstanten reellwertigen Funktionen.
* ???: Garbe der differenzierbaren/glatten Funktionen.
* ???: Garbe der holomorphen Funktionen. Aus interner Sicht diskret!


=== Kohärente Topoi

* Kohärente Topoi haben genügend Punkte. (Deligne)
* Big_et(X) ist kohärent, da definierbar als Topos über dem Situs Aff/X,
  Affine quasikompakt sind und daher Überdeckungssiebe endlich erzeugt sind.
  (Was heißt das genau?)
  http://mathoverflow.net/questions/145821/interaction-petit-topos-gros-topos


=== Nächste Schritte

* Für den Rückzug mit f^* statt f^(-1) auf Spec k(x)
  geeignete Transferprinzipien herleiten.

* Halm vs. kleine Umgebung kategoriell verstehen.

* Assoziierte Punkte?
