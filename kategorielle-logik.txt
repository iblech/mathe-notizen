* http://ljk.imag.fr/membres/Dominique.Duval/Slides/capp10.pdf
* A categorical semantics of quantum protocols: http://arxiv.org/abs/quant-ph/0402130

* Ein altes Paper:
  Michael Fourman, Continuous Truth I.

* http://www.dtc.ox.ac.uk/people/12/frot/CoherentTopoi.pdf
  Empfohlen von John Baez. Diskutiert den Zusammenhang zwischen Gödels
  Unvollständigkeitssatz und Delignes Theorem.

* http://www.cs.bham.ac.uk/~sjv/GeoAspects.pdf
  Ist eine schöne Einführung.


=== Bedeutung der Identität

"=" ist \exists längs der Diagonale. (Das kam eventuell in Jonas Freys Vortrag
im IHÉS vor.)


=== Zusammenhang zwischen [[.]] und |==

Siehe Shulmans Stack-Paper. Sei phi eine Aussage über einem Topos E mit einer
freien Variable x. Dann definiert die Kripke-Joyal-Interpretation von phi eine
Prägarbe auf E, nämlich

    A |--> { a : A --> X | A |== (a^* phi)[x/a] }.

Das ist eine Unterprägarbe von Hom(__, X). Diese nun wird dargestellt durch

    [[x:X. phi]].

NB: Diese Unterprägarbe ist sogar eine Garbe, also ein richtiges Unterobjekt in
Sh(E). Das klärt ein wenig die Bezeichnung "Stack-Semantik".


=== Schnitte von [[x:X. phi]] in einem Garbentopos Sh(Y)

Die U-Schnitte von [[x:X. phi]] gerade diejenigen U-Schnitte von X, die in der
Kripke-Joyal-Semantik die Aussage phi erfüllen. (Wende dazu den genannten
Zusammenhang auf A := Hom(__,U) an.)

* Die Formel "forall y. xy = 0 ==> x = 0" (d.h. "x ist regulär") ist nicht
  geometrisch. Trotzdem kann man einfach angeben, wie das Unterobjekt der
  regulären Elemente einer Ringgarbe R aussieht:

      Reg_R(U) = { x \in R(U) | U |== phi(x) }
               = { x \in R(U) | x regulär in allen R_p, p \in U }.

  Denn für festes x ist phi(x) eine geometrische Sequenz.


=== Schnitte von [[ { x:X | phi } ]] in einem Garbentopos Sh(Y)

Betrachte das Pullbackdiagramm

    [[ x:X. phi ]] --------> 1
         |                   |
         |                   |
         |                   |
         v                   v
         X --------------> Omega  (das ist, modulo Curryfizierung,
                 chi              die Interpretation [[ {x|phi} ]])

auf U-Schnitten; da Schnitte nehmen linksexakt ist, bleibt das ein
Pullbackdiagramm. Da aber Omega(U) nicht viel mit der externen Menge der
Wahrheitswerte zu tun hat, lässt sich chi_U nicht als klassifizierende
Abbildung einer Teilmenge von X(U) lesen.

Es gilt zumindest für alle s aus X(U): chi_U(s) = U <==> U |== phi[s/x].


=== Geometrische Formeln und Konstruktionen

* Geometrische Formeln vertragen sich gut mit dem Zurückziehen längs
  geometrischer Morphismen:

      f^* [[phi]] = [[f^*(phi)]].

* Mittels Induktion über den Formelaufbau kann man leicht folgendes zeigen:
  Sei phi eine geometrische Formel über eine Teilmenge U. Sei x in U.
  Dann gilt:

      Set |== x^* phi   <==>   ex. x \in V \subseteq U: V |== phi.

  Falls phi auch "==>" oder "forall" enthält, gilt nur "<==" -- allerdings nur
  dann, wenn man noch die volle Induktionsvoraussetzung für alle Teilaussagen
  zur Verfügung hat. Wegen der Charakterisierung der Gültigkeit geometrischer
  Sequenzen ist die Rückrichtung aber sowieso trivial.

  Die Äquivalenz gilt auch, wenn Teilaussagen der Form "x \in A" für
  Teil"mengen" A \subseteq M vorkommen. Die muss man allerdings richtig
  verstehen: Nicht die Menge A als globales Element von [M, Omega] auffassen,
  sondern als Untergarbe von M. Wenn A selbst über eine geometrische Formel
  definiert wurde, kann man auch gut angeben, wie die zurückgezogene Untergarbe
  x^* A aussieht.

* Damit ist es leicht, zu zeigen, dass eine geometrische Sequenz genau
  dann auf einer offenen Teilmenge U gilt, wenn sie an allen Halmen gilt.

* Eine *Konstruktion* heißt geometrisch, wenn sie sich nur aus Dingen
  zusammensetzt, die unter solchen Rückzügen erhalten bleiben, insbesondere
  sind das Produkt und Koprodukt, aber auch Interpretationen von geometrischen
  Formeln (nicht Sequenzen!).

* Etwa ist R^x := { x:R | exists y:R. xy = 1 } eine geometrische Konstruktion,
  Reg(R) := { x:R | forall y:R. xy = 0 ==> y = 0 } aber nicht.

* Objekte natürlicher Zahlen und Listenobjekte kommutieren mit Rückzug.

* Die Konstruktion "freier R-Modul auf" kommutiert ebenfalls. Das ist NICHT
  klar, wenn man dazu die feinste Äquivalenzrelation mit ... verwendet,
  aber SCHON, wenn man ihn einfach als Koequalizer definiert:

      Rel ==> L(R x X) --> coeq,

  wobei Rel = { (v,w) | v,w sind mit einer elementaren Umformung miteinander
  verbunden }. Die beiden Morphismen aus Rel sind die beiden
  Projektionsmorphismen. Denn Koequalizer, Rel und L sind alle geometrisch.

* Auch die Konstruktion "Menge der (Kuratowski-)endlichen Teilmengen"
  ist geometrisch. Siehe http://www.cs.bham.ac.uk/~sjv/GLiCS.pdf, Seite 10.

* Auch die Konstruktion "Kählerdifferentiale" ist geometrisch.

* Rückzug von Örtlichkeiten funktioniert, ist aber nicht ganz trivial:
  Siehe Spitters/Vickers/Wolters, Gelfand spectra in Grothendieck toposes using
  geometric mathematics, http://arxiv.org/pdf/1310.0705.pdf.

* Die Hom-Konstruktion ist im Allgemeinen nicht geometrisch, aber schon, wenn
  der vordere Modul von endlicher Präsentation ist. Siehe meine Antwort auf
  StackExchange: http://math.stackexchange.com/questions/16203/why-doesnt-hom-commute-with-taking-stalks/645385#645385


=== Generischer Halm

Sei xi ein generischer Punkt eines topologischen Raums X. Das soll heißen, dass
der Abschluss von {xi} ganz X ist. Dann gilt: Jede nichtleere offene Teilmenge
enthält xi. Daher folgt für eine geometrische Formel phi über X:

    phi gilt am generischen Halm  <==>
    phi gilt auf einer dichten offenen Teilmenge von X.

In diesem Sinn ist zu einem lokal geringten Raum (X,O_X) die "Keim-Umgebung"
(pt,O_{X,x}) also nicht nur in einem geometrischen Sinn keimartig, sondern auch
in einem logischen.

Verallgemeinerung: Sei xi ein Punkt, sodass der Abschluss von {xi} eine Menge A
ist. Dann gilt: Jede nichtleere offene Teilmenge von A enthält xi. Somit gilt
für geometrische Formeln phi über X:

    phi gilt am Halm xi  <==>
    phi gilt auf einer offenen Menge, die xi enthält  <==>
    phi gilt auf einer dichten offenen Teilmenge von A
        (ziehe hier phi längs A ^--> X zurück und rede
        dann in der internen Sprache von Sh(A))


=== Sh_j(E) vs. Sh(E) mit j-Übersetzung

* Gelte für einen modalen Operator Box:

      (Box phi)^Box = Box(phi^Box).

  Dabei bezeichnet (__)^Box die Box-Übersetzung (nur auf Formeln, ohne Änderung
  der Objekte).

  Das ist erfüllt für folgende Operatoren:

  * Box = negneg.
  * Box = (__ --> alpha) --> alpha.
  * Box = alpha --> __.
  * Box = __ v alpha.

  Wenn diese Bedingung erfüllt ist, so fühlt sich Box unter die Box-Übersetzung
  wie die Identität an:

      (Box phi ==> phi)^Box

    = (Box phi)^Box ==> phi^Box

    = Box(phi^Box) ==> phi^Box, das ist stets richtig.

  Das ist wohl einer der Gründe, wieso man bei der Box-Übersetzung nicht die
  Objekte vergarbifizieren muss: Sie fühlen sich schon garbifiziert an!

* Im Allgemeinen ist der Vergissfunktor Sh_j(E) --> Sh(E) ja nur linksexakt.
  Was bringt die Ableitung dieses Funktors (etwa auf abelschen Gruppen)?
  Etwa im Fall Set_negneg --> Set?
  Wie sieht die aus?
  Was bringt das im Fall j = ((__ --> !x) --> !x)?

  Ein explizites Modell sieht so aus, über Ext^1(ZZ, __),
  wobei ZZ die konstante Garbe ZZ bezeichnet:

  Zu einer kurzen exakten Sequenz 0 --> X --> Y --> Z --> 0 in Sh_j(E)
  (also j-gibt es zu jedem z:Z ein Urbild) gehört die Sequenz

      0 --> X -f-> Y -g-> Z --> Ext^1(ZZ,X)

  in E, mit Ext^1(ZZ,X) = { [0 --> X --> ? --> ZZ --> 0 j-exakt] }.
  Die Dimensionsshiftabbildung sieht so aus:

      z |--> [0 --> X --> { (y,r) | g(y) = rz } --> ZZ --> 0].

  Diese Sequenz ist tatsächlich j-exakt.

* Welche Bedeutung hat es, mit (__)^j zu arbeiten, aber über Objekte
  von E zu sprechen? Klingt erstmal so, als ob man Garbensprache verwenden
  würde, um über Prägarben zu sprechen. Das wäre ja nicht sound.
  Aber vielleicht arbeitet man tatsächlich automatisch mit den assoziierten
  Garben.

* http://www.pps.univ-paris-diderot.fr/~mellies/mpri/mpri-ens/articles/hyland-effective-topos.pdf
  Evtl. ist meine j-Erkenntnis nicht neu.


=== Modale Logik

* Sei J intuitionistische Logik ergänzt um einen modalen Operator (der
  dieselben Axiome erfüllt wie eine Lawvere--Tierney-Topologie). Dann gilt:

      J |== phi  genau dann, wenn  E_j |== phi für alle Topoi E und LT j.

  Das steht in Goldblatt, Grothendieck Topology and Geometric Modality, Seite 164, (7.14).
  (Danke an Tadeusz Litak von PSSL 99.)


=== Bemerkungen, die konsolidiert werden müssen

* "Set |== x^* phi   <==>   ex. x \in V subseteq U: V |== phi."

  Das gilt nicht für das "große E", also unbeschränkte Quantifikation.
  Die Hinrichtung passt noch. Aber nicht die Rückrichtung.

  Es sei denn, man schränkt sich auf lokal konstante Garben ein.

* "X |== forall A. (phi --> psi)  <==>  f.a. x \in X, Mengen A: phi_x --> psi_x."

  Das stimmt, für geometrische phi, psi.

* Sei X mit folgender Eigenschaft: Jede offene Teilmenge lässt sich durch
  komapkte offene Teilmengen überdecken. Das ist etwa für Schemata erfüllt!

  Sei phi eine solche Aussage, sodass für jede kompaktoffene Teilmenge U
  gilt: U cap [phi] ist wieder kompakt.

  Das ist etwa für phi = "f invertierbar" auf einem Schema erfüllt!

  Dann gilt folgendes logisches Prinzip:

      X |== (phi --> bigvee_i psi_i) --> bigvee_i (phi --> psi_i),

  wobei (psi_i) eine monotone Familie über eine gerichtete Indexmenge ist.


=== Sh(X) boolsch

* Sh(X) ist genau dann boolsch, wenn für jede offene Teilmenge U gilt:
  U ist die einzige offene dichte Teilmenge von U.

* Sei X ein T1-Raum, d.h. für je zwei verschiedene Punkte existiert eine
  offene Menge U, die den einen, aber nicht den anderen Punkt enthält.
  (Das ist äquivalent dazu, dass alle Punkte abgeschlossen sind. Schemata sind
  also im Allgemeinen nicht T1! Ein Spektrum eines Rings ist genau dann T1,
  wenn der Ring <=null-dimensional ist.)

  Dann gilt: Sh(X) ist boolsch <==> X ist diskret.

  "<==": Sei V in U offen, dicht. Sei x in U. Dann {x} \subseteq U offen,
  nichtleer. Also V cap {x} != {}. Also x in V.

  "==>": Sei x in X. Angenommen, {x} ist nicht offen.
  Setze U := bigcup { V | V offen mit x nicht in V } = int(X \ {x}).
  Dann ist U dicht in X: Sei W offen, nichtleer. Dann muss ein y in W
  existieren, das nicht gleich x ist. (Denn enthielte W nur x, so wäre {x}
  offen.) Nach T1-Voraussetzung existiert dann eine offene Menge V, die y aber
  nicht x enthält. Daher ist der Schnitt U cap W nicht leer: Er umfasst V cap W,
  und diese Menge enthält y.
  Somit ist U = X. Das ist ein Widerspruch.


=== Besondere Interpretationen

* Für eine Formel phi über X gilt genau dann, dass [[phi]] (nicht nur offen,
  sondern auch) abgeschlossen ist, wenn intern "phi oder neg phi".

  Die Hinrichtung ist klar: X = [[phi]] cup [[phi]]^c ist dann eine offene
  Überdeckung. Die Rückrichtung ist auch nicht schwer.

* Die Untergarbe [[ { x : 1 | phi } ]] der terminalen Garbe ist genau dann
  lokal konstant, wenn [[phi]] clopen ist, wenn also intern "phi oder neg phi"
  gilt.

  (Zeige als Lemma: [[ { x : 1 | phi } ]] ist genau dann konstant, wenn [[phi]]
  leer oder ganz X ist. Nutze, dass man Abgeschlossenheit lokal testen kann.)


=== Reelle Zahlen

* Dedekindsche reelle Zahlen: Garbe der stetigen reellwertigen Funktionen.
* Cauchy-Zahlen: Garbe der lokal konstanten reellwertigen Funktionen.
  (Wenn der zugrundeliegende Raum lokal zusammenhängend ist -- siehe Elephant
  D4.7.12.)
* ???: Garbe der differenzierbaren/glatten Funktionen.
* ???: Garbe der holomorphen Funktionen. Aus interner Sicht diskret!


=== Eigenschaften konstanter Garben

* Sei phi eine Formel, in der nur konstante Garben vorkommen. Dann gilt
  (konstruktiv!):

      U |== phi  genau dann, wenn  U <= sup { T | phi }.

  Beweis durch Induktion; klar für top, bot. Für wedge wegen der
  in Rahmen geforderten Distributivität.


=== Lokal konstante Garben

Im effektiven Topos ist der Untertopos der Mengen gerade der Untertopos der
negneg-Garben. Ich wollte das für lokal konstante Garben nachbauen; das
funktioniert aber nicht:

* Angenommen, es existiert ein modaler Operator Box, sodass eine Garbe E
  auf X genau dann lokal konstant ist, wenn sie eine Box-Garbe ist.

* Dann folgt, dass eine Aussage phi genau dann Box-stabil ist, wenn
  ihre Interpretation clopen ist, wenn also phi oder neg phi.

* Wegen der Tautologie

      Box alpha  <==>  forall beta. (beta Box-stabil und alpha=>beta) ==> beta

  erhält man so einen Ausdruck für Box alpha. Vereinfachung zeigt aber, dass
  dann

      Box alpha  <==>  neg neg alpha

  gilt. Und bekanntlich gibt es Garben, die nicht lokal konstant, aber trotzdem
  negneg-Garben sind. (Beispiel?)

* Die ausgeschriebene Tautologie führt übrigens zu folgender Interpretation von Box:

  V |== Box W genau dann, wenn

      für alle offenen U <= V, beta <= U gilt:

          W cap U <= beta  und  beta <= U abgeschlossen  ==>  U <= beta.

Vermutlich war das ganze sowieso zum Scheitern verurteilt, denn Kerne von
Morphismen zwischen lokal konstanten Garben müssen nicht wieder lokal konstant
sein. (Beispiel?)

Ein Vorschlag, der zumindest auch für Garben der Form {x:1|phi} funktioniert,
ist

    "E lokal konstant  <==>  E diskret und (E bewohnt oder E nicht bewohnt)".

Aber auch hier stimmt die Rückrichtung nicht. Vielleicht klappt folgendes, aber
das ist nicht so schön:

    "E lokal konstant  <==>  bigwedge phi",

wobei das bigwedge über alle Aussagen phi läuft, die für klassische Mengen
erfüllt sind. (Wenn man das allgemein genug interpretiert, stimmt die
Äquivalenz trivialerweise: Wähle phi := "bigvee_{Mengen I} (E = \ul{I})".)


=== Konstruktion von modalen Operatoren

Unter welchen Voraussetzungen definiert die Setzung

  Box alpha := forall beta. (phi(beta) und alpha => beta) => beta

einen modalen Operator?

Hinreichend dafür ist, dass für phi gilt:

    phi(beta)  ==>  phi(delta => beta).


=== Kohärente Topoi

* Kohärente Topoi haben genügend Punkte. (Deligne)
* Big_et(X) ist kohärent, da definierbar als Topos über dem Situs Aff/X,
  Affine quasikompakt sind und daher Überdeckungssiebe endlich erzeugt sind.
  (Was heißt das genau?)
  http://mathoverflow.net/questions/145821/interaction-petit-topos-gros-topos


=== Platonismus vs. Formalismus

Lambek, Scott. Reflections on a categorical foundations of mathematics.

Für einen Intuitionisten ist Platonismus wunderbar mit Formalismus vereinbar:
durch Arbeit im initialen (Elementar-)Topos. Denn:

* Eine Aussage besitzt genau dann einen intuitionistischen Beweis, wenn
  sie im initialen Topos gilt.

* Der initiale Topos befriedigt Platonisten, denn als ein initiales Objekt
  ist er eindeutig (in einem 2-kategoriellen Sinn).

* Er befriedigt Formalisten, da er rein syntaktisch/linguistisch konstruiert
  werden kann.

Außerdem:

* Er befriedigt Logizisten, weil die interne Sprache des initialen Topos
  eine Form von Logik höherer Ordnung ist.

* Er befriedigt Konstruktivisten, da der initiale Topos die
  Disjunktionseigenschaft und die Existenzeigenschaft hat.

Dieser Standpunkt heißt wohl "constructive nominalism".

Nur Achtung: Der Beweis, dass der initiale Topos wirklich ein Modell mit den
gewünschten Eigenschaften ist, setzt die metamathematische Annahme, dass es ein
Modell von Mengenlehre gibt, voraus. (Letzter Satz des Artikels)

Siehe auch: http://www.math.mcgill.ca/barr/lambek/pdffiles/WorldMath.pdf


=== Kommutative Theorien

http://www.wra1th.plus.com/gcw/rants/math/MathPhant.html

Suppose we have two operations huey and dewey in an algebraic theory. We say
that they commute if for any rectangular array of elements, with rows the right
size for huey and columns the right size for dewey, the application of huey to
each row and dewey to the resulting column yields the same as applying dewey to
each column and then huey to the resulting row. This can be expressed in a way
that makes no mention of elements. An algebraic theory is commutative if any
pair of its operations commute. This generalizes the notion of a commutative
ring.

Commutative algebraic theories have very nice properties. Every operation is a
homomorphism. So the set of homorphisms from one model to another has a
canonical structure as a model itself. This makes the category of models
closed. Furthermore, the resulting internal Hom functor has a left adjoint
which generalizes the tensor-product construction for modules. A free model on
one generator is a unit for this tensor-product.

Beispiele:

* Theorie der R-Moduln, wobei R ein kommutativer Ring ist
* Theorie von F_1
* Theorie der vollständigen Verbände (mit Suprema bewahrenden Morphismen)
* Theorie, die für jedes n-Tupel von nichtnegativen reellen Zahlen mit Summe 1
  eine n-stellige Operation haben. Modelle sind unter anderem konvexe Mengen in
  euklidischen Räumen.


=== Gleichheit von Beweisen

Von Peter Arndt empfohlen: Lambek.


=== Nächste Schritte

* Für den Rückzug mit f^* statt f^(-1) auf Spec k(x)
  geeignete Transferprinzipien herleiten.

* Halm vs. kleine Umgebung kategoriell verstehen.

* Assoziierte Punkte?

* Wie konstruiert man eigentlich den freien Topos?
